# Размышления не тему использования структур Поляра для создания языка программировани или системы программирования

### 20250428 17:29 Мысли на тему
Со структуризаций Поляра почти все ясно. Не ясно: рекурсивные структуры типа TYPE и параметризация типовых построений. Пока это можно отложить. Далее, мы будем предполагать что есть аппарат лямбда-функций. Главное, что хотелось бы понять - это некоторый универсальный механизм работы с отображениями п-значений в ту или иную среду. Это может быть оперативная память, могут быть байтовые потоки и даже битовые потоки, это потоки интернета. Возможно также рассмотрения могут быть применимыми к хранилищам, в том числе, распределенным. 

Естественным образом напрашивается представление об источниках и стоках (sources, destinations). Берем источник (структурированных) данных, получаем из него структурное значение, напр. в виде потока объектов, преобразуем этот поток и заводим его в приемник. Либо поток используется по пути для чего-то полезного. Либо вместо источника создаем генератор и уже он порождает поток. Хорошо бы создать удобный формализм. 

Попробую get-set:
``` 
p-value = get(source);
set(p-value, destination);
```
В некоторых случаях источник может порождать под-источники. Например в случае регулярного размещения в ОЗУ структурного значения. Регурярное размещение подразумевает выполнение свойств: значение разбито на голову и хвост. Голова всегда фиксированного для данного типа размера. Поэтому можно данное этого типа "прикрепить" к приемнику данного типа. Для систем РВ (реального времени) перед прикреплением надо убрать хвост из поля и утилизировать ресурсы (памяти). Соответственно, должны существовать процедуры выделения полей. Напр.:   
```
source = field(source, [номер поля]) // для записей номер поля это константа
```
И получения атрибутов структур:
```
целое = count(source) // для последовательностей
целое = variant(source) // для объединений
```
Другим принципиальным вариантом исток/стока являются сериализации. Есть 2 варианта текстовой сериализации, байтовая сериализация (возможно в разных вариантах) и битовая сериализация (тоже в вариантах). Для сериализации важно иметь начало потока, пополнение потока, выявление текущего офсета, установка офсета, чтение элемента потока. Важно использование сериализаций в: базах данных, в коммуникациях, в командных интепретаторах (?). 

### 20250429 06:24
Пришла в голову мысль. Взять за основу подмножество C# и сочинить свой язык. Только применить другую систему структуризации. Поляровскую. Как это может выглядеть? Берем процедуры, в минимальном варианте классы и методы, берем произвольное число параметров (может быть...), берем yield return, берем основные управляющие конструкции. Берем поляровские структуры, берем потоковую обработку и отложенные вычисления. Все вышесказанное переводим в структурный вид, для него сочиняем несколько текстовых сериализаций и "протаскиваем" все это через механизмы обработки. 

Возможно важнейшей частью подхода может быть новая семантика приваивания. Суть не слишком сложная. Присваивание, это некоторые манипуляции между полем и (структурным) значением. А еще надо понять суть перечислителей. В C# они как-то не сильно концепуализированы. Может так и надо, может надо по-другому. Кроме присваивания может нужно именование. Хотя это вызывает вопросы. При именовании мы хотим сохранить структурное значение в уже вычисленном виде для того, чтобы его использовать в разных местах. Обычная схема сохранения - присваивание. Неудобство присваивания в том, что присвоенное значение можно менять, а мы может это не имели ввиду для повторного использования. А как можно сохранить значение без присваивания?

Теоретически, значение это набор объектов. Если его сохранять, то это будет то же сериализованное значение. То есть, некий вариант присваивания. Набор объектов интересен тем, что значения могут "крутится" в цикле обработки не захватывая память. Но так их не сохранить, нужно сериализовать.

Итак, есть основная конструкция - присваивание. Есть ее вариант, а может и основа - передача параметра. Передача параметра выглядит как "вложение" значения в поле, определяемое параметром. То есть, очень похоже на присваивание. Обработка присваивания происходит рекуррентно и "сверху вниз". То есть берется тип поля и берется "верх" значения и сопоставляются (matching?). Если тип простой (целый,... строка), то ожидается и значение соотвествующего типа. Если тип составной (запись, последовательность, объединение), то ожидается либо значение этого типа либо конструктор значения этого типа. В случае конструктора, сопоставление задает новые пары тип-значение. Процесс сопоставления, рекуррентно продолжается. Он останавливается на ситуации, когда тип значения совпадет с типом поля. 

Какие моменты можно выявить при сопоставлении? Для записи - ничего особенного. Правда в ряде языков matching используется для как-бы именования полей. Хорошо бы это использовать... Для последовательности можно было бы использовать и перечисление элементов и поток, который автоматически превращается в массив. Также не исключена конструкция "первый-остальные" либо "начальные-последний". В любом случае, пора подумать над переменными сопоствления. Кажется, пора выходить на логическое программирование. Я очень давно об этом мечтал. Может и предикатная форма будет уместна. 

Как бы аккуратно ввести переменные сопоставления, а потом их полезно использовать. Попробую стартовать от предикатной формы. Пусть есть предикат P(x, y). Это определяемый предикат, его определение (в Прологе) может быть каким-то типа:
```
P(A, B) :- Q(A, C), R(C, B).
```
Это означает, что предикаты определения могут иметь параметрами и константы и переменные. А переменные служат информационной "опорой" для вычисления чего-то другого. По старым своим прикидкам я выявил то, что образцы могут быть в заголовке определения, особенно если рассматриваются альтернативные типы. Это означает следующее: есть единая сигнатура функции, параметры в этой сигнатуре структурные. После этого, мы задаем заголовом функции с разными сопоставлениями и через них вычисляем конретный вариант тела определения. На этом пути есть трудности. Что если будут сопоставлены два и более варианта или ни одного?

Но с другой стороны, если иметь вариаты switch, можно каждую из алтернатив выстроить в систему обработки. И та же задача будет достаточно удобно решена. Кажется... Надо посмотреть как это делается в других языках, напр. Python.  

### 20250430 09:32
Из Питона также можно взять цикл по индексу, который там делается через итератор, что весьма логично.

Пройдусь по важным конструкциям, которые надо зафиксировать в языке. Определение метода, определение процедуры:
```
Definition =
    type^TYPE,
    meth^Type_result Type_object [formal_param]
    func^Type_result [formal_param]
```
Попробую начать с другой стороны. Со стороны исполнения. Пусть имеется определение функции. Функция не активируется пока не будет вызова. В вызывающем контексте есть стек данных и есть вызов функции. Оставим место для результата (пустое поле на стеке вызова), далее сформируем нужное количество пустых полей для параметров. Далее, вычислим выражения значений фактических параметров и вычислим значения полей. Последнее требует расшифровки. Значение поля это "указатель" на вычисленное поле переменной, которая не будет изменяться во время вычисления данной функции. Кстати, здесь намечается противоречие для процедур с yield return. Что такое "указатель"? Это некоторая координата по которой можно читать структурное значение и заменять его на другое. Таким образом, для параметров in выделяется место для реального значения, для параметров out и inout - место для координаты. Вычисление поля дает координату, вычисление выражения дает прикрепленное значение. 

После выделения места для параметров, в контексте вычисляются значения, помещаемые в фактические параметры. И запускается процедура. Процедура работает в контексте своих параметров. Что делать с доступностью и использованием переменных более "высшего" существования (глобальные и внешние локальные), я пока не знаю. В принципе, это непростая задача и решается она через стек вызова (кажется). 

Далее идут вычисления, определенные в теле функции. Это операторы присваивания. Соответственно, на каждую переменную (сразу) выделяется место и операторы присваивания строют на этом месте значения. Причем, оператор присваивания проверяет пустое ли поле и утилизирует (опустошает) поле перед занесением туда головы значения. Более общий случай оператора присваивания - это присваивание вычисленному полю. Это означает, что сначала идет вычисление значения поля в текущем контексте, т.е. координаты, а потом уже все остальное. Каждое присваивание "очищает" голову поля. Итак, у нас есть поля, переменные и указатели. Указатели - координаты головы значения. Указатели или координаты часто являются результатами промежуточных позиционных манипуляций и вычислений. Но есть и прямое запоминание - в фактических значениях параметров in/out. 

Продолжу анализировать процесс интерпретации кода функции. Есть оператор return. Он останавливает вычисления и возвращает управление вызвавшей процедуре. Для функций - он возвращает результат. Это означает, что в "ячейку" результата записывается голова вычисленного значения. И все локалы функции утилизируются. Вопрос: а может ли быть функция, которая вычисляет поле? Подозреваю, что не может, но я над этим еще не думал. Почему не может? Возможно потому, что надо сначала иметь поле внешнего объекта, а потом вычислять его подполе. Ссылки на внешние объекты мы получаем только через параметры in/out. Но по идее, они нужны или для взятия значений или присваивания значений. В любом случае, в теле функции вычисленное подполе мы сразу используем.   

Сейчас после обеда немного прогулялся и придумал вот что: написать модель, определяющую как устроена система обработки данных. Здесь не понадобятся конкретные операторы, управляющие операторы и т.д. Только значения, поля и указатели. А также - среда оперирования. 

### 20250501 14:26
Сегодня Первое мая! Даже не знаю как сейчас это праздник называется. Ну да бог с ним. Мысли "крутятся" вокруг заданной темы - модели работы с данными. 

Что входит в модель? 1) объекты достаточно произвольной природы; 2) типы данных; 3) представление о сериализации (или о проекции?); 4) координаты; 5) разные варианты свойств сериализации; 6) базовое отображение (проекция) на оперативную память; 7) работа с переменными; 8) сегмент (блок) обработки

Сейчас посидел на скамейке, подумал и... придумал(?). Придумал насчет параметризации типов. Сейчас в процедурном варианте я пишу, напр.:
```
var tp_seq = new Sequence(tp_el);
```  
А если допустить, что tp_el - это параметр, который при подстановке будет принимать разные значения? Интересно... Но наверное это исказит имеющуюся работу с типами. Может проэкспериментировать чтобы лучше понять?

Вот экспериментальный вариант программы:
```
using Polar.DB;
partial class Program
{
    public static void Main()
    {
        Console.WriteLine("Hello, World!");
        PType ty = new PType(PTypeEnumeration.integer);
        PType zap = new PTypeRecord(
            new NamedType("aaa", new PType(PTypeEnumeration.sstring)),
            new NamedType("bbb", new PType(PTypeEnumeration.real))
        );

        var v1 = new object[] {1, 2, 33};
        Second(ty, v1);
        var v2 = new object[] 
        {
            new object[] {"s1", 1.11},
            new object[] {"s2", 2.22},
            new object[] {"s33", 33.33}
        };
        Second(zap, v2);
    }
    private static void Second(PType seq_e, object sequence)
    {
        PType tseq = new PTypeSequence(seq_e);
        object el = ((object[])sequence)[1];
        Console.WriteLine(tseq.Interpret(sequence));
        Console.WriteLine(seq_e.Interpret(el));
    }
}
```
Она работает, а в процедуре Second задается тип-параметр seq_e и значение, адаптированное к этому типу. Это не слишком надежно (совсем ненадежно), но что делать? Может опять решать задачу "в лоб"?
Где здесь могут быть недиагностируемы ошибки? Очевидно, в конструировании объектов. У меня нет конструкторов объектов, но они могли бы быть. Вообще, о надежности программирования можно было бы озаботиться специально. 

Но это не все. Для корректности и удобства помнится в C# при указании суперкласса можно указать и некоторые его свойства. Но здесь (пока) не суперкласс. 

### 20250502 09:45
Подумал над параметризацией типов. Вроде даже с рынешней реализацией получается. Провел эксперимент, описанный вчера, сегодня его несколько модифицировал - получилось. Суть решения в том, чтобы типы также передавались как параметры и участвовали в процедурах наряду с константами. Единственное (надеюсь) слабое место - вычисление размера головы структурного значения. Для большинства типов (атомарных и конструируемых) значение головы фиксировано реализацией. Только для записи есть неопределенность в виде суммы длин составляющих подтипов. В Polar.DB я "химичил" тем, что для записей устанавливалась длина -1 и если при запросе определялось это значение, то длина вычслялась рекурсивным запросом. И записывалась в поле длины. Видимо придется это место изменить и размер головы всегда вычислять динамически и рекурсивно. 

Теперь надо вернуться к канонической форме процедуры. Допустим,  есть описание лямбда-функции:
```
lamda((t1, t2, ...), (x1, x2, ...) (операторы))
``` 
Фактически, есть набор типизированных параметров. Таким образом, есть поле значений которые можно использовать в выражениях с получением новых значений, результаты можно присваивать полям. Если не создавать побочные эффекты, присваивание может быть только для  промежуточных (?) переменных и результату.  

### 20250509 16:38
Мы вернулись с Семинского перевала и сейчас я обнаружил, что не зафиксировал важные, пришедшие в голову мысли. 

Главная новая мысль: рассматривать поляровские значения не как пары (указатель на значение, тип), а как тройку в которой добавляется "категория поля". Эта категория может быть довольно разной. Это поток байтов, это структурное значение, это поток битов, это разные модели TCP-взаимодействия. Кажется, вообще структурное значение приобретает другой смысл. Это координата в каком-то из подпространств.

### 20250510 06:41
Попробую продолжить рассуждения. Пусть есть источник или сток или переменная. Наверное, квалификацию менять нельзя. Также пусть есть определение вида потока: байтовая память, битовый поток, байтовый поток. Во всех случаях, есть координата поля. Какие манипуляции можно проделать с координатой? Кажется, что многое зависит от квалификации указателя. Если это сток, то put(value) изменит координату в указателе на размер величины или головы. get() даст двойной эффект: изменение координаты и получение значения. set(value) работает только для переменной и произведет очищение предыдущего значения и установку нового значения. 

Как-то мне не нравится наличие побочных эффектов, надо бы сделать изящнее. Начну с того, что есть три метода put, get, set. Или может только два: get(coor), set(coor, value). Это скалярные действия хотя и со структурными значениями. Надо ли вводить потоковые действия типа enumerable <- getflow(coor)? Неочевидно. Может лучше избавиться от абстрактного p-объекта и в операторах указывать и источник и приемник. Это как-то плохо выгдядит на фоне концепций функционального программирования.  

Попробую рассмотреть новые смутные идеи через "призму" потокового подхода и функционального программирования. Что такое поток с "физической" точки зрения? Рассмотрим фрагмент обработки:
```
foreach (var el in elflow)
{
    // Обработка el
}
```
Здесь важно то, что elflow - итератор. В Питоне (кажется) итератор вообще почти главная концепция. Что делает итератор? Он выдает очередной элемент и сдвигает "головку" чтения на следующий. Из-за побочного эффекта итератора могут возникнуть (и возникают!) ошибочные ситуации. Но пока это не важно. Важно то, что итератор последовательно показывает указатели на значения или сами значения. Проще считать, что указатели.  

### 20250626 11:08
Я серьезно задумался над потоками и итераторами и не смог увидеть простую подель за ними. Я попытался наметить обработку данных на стеке и опять же не додумал. Как все должно выглядеть? 

Мы запускаем прецедуру итератора, она перебирает элементы потока и подвергает их обработке. Подвергание обработке, это небольшое колчество базовых вариантов: генерация потока, поэлементное функциональное преобразование, фильтрация. Еще аггрегация и "размножение". Последнее - это когда результатом преобразования является поток элементов и эти потоки сливаются воедино через SelectMany. 

Ключивым для понимания обработки потоков является следующий фрагмент:
```
IEnumerator<int> enumerator = collection.GetEnumerator();
while (enumerator.MoveNext())
{
    var item = enumerator.Current;
    Console.WriteLine(item.ToString());
}
```
Создается объект "эньюмератор", потом организуется цикл с запросами к методам эньюмератора. Поток "съедается" внутри цикла. А если не съедается? Он может подвергнуться следующему этапу обработки, он может породить новый поток. Певое реализуется через вставление преобразования вместо выдачи. Второе реализуется через yield return. Кстати, а можно подобный yield return делать из блока или как-то так?

В вопросе реализации yield return существенным вопросом является то, куда девать наработанные значения потока. Может надо создать универсальный буфер? И переключаться с наработки значений потока к потреблению значений потока. 

Тогда что? Вернемся к
```
IEnumerator<int> enumerator = collection.GetEnumerator();
while (enumerator.MoveNext())
{
    var item = enumerator.Current;
    // Точка потока
}
```
В разделе "Something to do" можно 1) фильтровать, 2) преобразовывать, 3) редуцировать.
Далее, можно преобразовать item в поток (или последовательность) и устроить внутренний цикл и уже во внутреннем цикле будет точка потока.  
```
IEnumerator<int> enumerator = collection.GetEnumerator();
while (enumerator.MoveNext())
{
    var item = enumerator.Current;
    IEnumerator<T> enumerator2 = F(item).GetEnumerator();
    while (enumerator2.MoveNext())
    {
        var item2 = enumerator2.Current;
        // Точка потока
    }
}
```
Такая конструкция дает SelectMany().

А вот yield return видимо можно делать только с помощью буфера. 

### 20250629 08:52
Я все больше склоняюсь к мнению, что надо делать как в Rust: вызов параметра по значению, вызов по ссылке, вызов по изменяемой ссылке. Синтаксически это касается только спецификации параметров, а какой код должен быть опрелеяется в зависимости от квалификатора. 

Проводка ссылок внутрь процедуры не несет опасности пока мы через ссылку не меняем значение. В условиях "леса деревьев" изменение "ветки" несет ту опасность, что на этой ветке может быть другая ссылка, которая перестанет быть правильной. Как это может произойти? Посмотрим по индукции. Назовем ссылку независимой если ее значение не содержит других ссылок. Пусть, по индукции, все имеющиеся в контексте вычислений ссылки являются независимыми. Или свободными. Вычисления осуществляют следующее: выделяют поля, т.е. вычисляют динамические ссылки, вычисляют значения и присваивают поля значениям. Поскольку ссылки являются независимыми, динамические поля также явлются независимыми. И присваивание полю значения "закрывает" поле и соответствующую ссылку. А теперь рассмотрим вызов процедуры. Мы вовнутрь передаем значения и ссылки, обратно получаем значение, а может и поле. Последнее - под большим вопросом. Передача вовнутрь ссылок создает внутри нового контекста новые ссылки. Они могут быть зависимыми. Это когда передаются через разные переменные поля от одной ссылки (от одного поля). Кажется, это единственный вариант появления плохой зависимости. Достаточно запретить эту ситуацию и вроде все в порядке. Есть исключение: когда мы передаем новому контексту разные "по горизонтали" поля одной записи. Это может быть не только при процедурном вызове, но и при открытии нового блока. Например при сопоставлении с образцом. Что-нибудь вроде:
```
let a, b, c = record.a, record.b, record.c;
```
В общем, надо думать... Особенно про yield return.

### 20250706 16:12
Еще раз попробую сформулировать свои достижения. 

Определяем поляровскую типизацию. Причем тип может быть параметризован, это делается через сборку типа, в которой принимает участие параметр. Все типы неизменяемые. Видимо это же касается других статических объектов, напр. лямбда-функция. Но это не факт. Может надо ввести динамическую типизацию, это когда порождается объект на основе сконструированного типа. Может и не надо. Естественно определяются структурные значения (объекты?). Определяется сериализация и десериализация. 

Далее идет понятие контекста. Это есть множество доступных структурных объектов. Контекст формируется как иерархическая конструкция. Сначала попробуем без ссылок. Есть переменные, состоящие из головы и хвоста. Есть описатель контекста, который состоит из описания "результата" и описателя параметров. По спецификации на стеке выделяется память под голову результата. Далее, выполняется цикл, в котором для каждого параметра выделяется место под голову, выполняется выражение, формирующее фактический параметр. 

Попробуем логику начинать от вычисления значения выражения. Есть выражение (код), есть поле, т.е. способ вычисления указателя на переменную (на значение). Есть стек, в вершину которого помещается результат вычисления выражения. В промежуточных точках, стек используется для вычисления подзначений. По окончании вычисления кода, полученное значение расположено на вершине стека. Но может и не так. Может значение будет "развернуто" в каком-то месте, на которое указывает указатель. При этом мы исходим из того, что базовым оператором является оператор присваивания. На стеке лежит указатель места и именно это место используется в качестве переменной присваивания. Кажется, это очень важно. А как должно быть в динамике исполнения? Спецификация - вот решение. Допустим, есть переменная, новое значение которой вычисляется выражением. Переменная определена полем или ссылкой (что видимо одно и то же). Пусть поле находится на вершине стека.   

### 20250726 09:12
Давненько я не писал заметки. А думать не переставал. Хочу изложить некторые из своих мыслей. 

Первая мысль - о модели памяти. Модель памяти структурированных объектов может быть довольно хорошей если применить математику для обеспечения целостности данных. Предлагается такая схема построения и обоснования: Сначала описать что такое корректные структурированные данные. Потом навести операционную семантику предоставив "пространство" изменений, потом показать какие ограничения не нарушают целостности или корректности данных. Эти ограничения потом внести в семантику самого языка или через модификаторы или как-то еще. 

Второе возникшее соображение связано с "прологовской" формой записи преобразований. Например, пишем:
```
<Сигнатура> имя_функции = (<имена параметров>) => <Преобразование>
```
... Как-то "с наскоку" не получается ...

Короче, если параметр - запись, то можно сделать "мапинг" и поименовать поля записи. Если параметр - последовательность, то можно предполагать, что это поток значений. Если параметр - объединение, то можно сделать неколько определений для разных вариантов объединения. Как-то слабо получается...

Нужно усиленно внести парадигму потокового программирования в мои построения. 

### 20250727 11:16
Промелькнула мысль: а может начать реализацию разрабатываемых идей с языка командной строки? А что, идея интересная. Просто я думал о командной строке как о дальнем этапе, а почему бы не попробовать. Надо подумать... А пока займусь доделкой информационных ресурсов и программ по итогам ЛШЮП-2025.

### 20250904 13:47
Прошел месяц с лишнем как я писал про соображения насчет нового языка программирования. Но думать я не переставал. Настала пора изложить продуманное. 

На сначала, посмотрю на обработку структурных данных, производимую на стеке. Предположим, голова значения располагается на вершине стека. Также у структурного значения есть хвост. Он располагается в куче. Рассмотрим важный оператор - оператор присваивания. В этом операторе есть выделение поля и есть вычисление выражение. А потом уже присваивание. Вычисление поля это очень эффективное действие, точнее, цепочка действий. А конце этой цепочки останется указатель на значение, лежащий на стеке. Пусть второй элемент стека как-то вычислен и лежит на стеке вторым элементом. Собственно оператор присваивания выполняется через следующие действия: 
- очистка хвоста поля;
- переписывание головы выражения. 

Вроде все.

А какая есть альтернатива? Все объекты есть указатели. Соответственно, в указатель поля просто записывается указатель выражения. А все остальное - конструкция объекта и сборка мусора.   

### 20250905 08:12
Как вообще может быть устроена виртуальная машина для поляровских объектов? Видимо через систему операций и функций. Поляровский объект, в общем случае, это ссылка на тип и сам объект. Видимо объект состоит из головы и хвоста. Уничтожение объекта предполагает уничтожение хвоста, причем рекуррентное. 

Итак, что можно делать с поляровскими структурами? 
Это - конструирование, сравнение, сериализация, выделение поля, клонирование, присваивание. В стиле функционального программирования было бы отказаться от модификации структур, но мы пока будем и эту группу действий иметь в виду. 

### 20250906 16:20
Я довольно внимательно изучил WebAssembly и даже попробовал откомпилировать и исполнить простейшие программы. Пока несколько тяжеловато, но уже что-то получается. Чем меня прельстил WA? Это довольно элегантная машина и синтаксис интересный. Этот синтаксис такой двойственный. Можно писать в стиле Лиспа (S-expression), можно сипользовать стек, получается что-то вроде обратной польской записи. Я такого подхода еще не видел. 

Я как раз искал удобный синтаксис в стиле Лиспа и удобную машину, чтобы реализовать свои идеи. Вроде подходит. Почти... Что не совсем соответствует? Главное решение, на которое надо бы решиться, это конструктуор объединений писать в виде: (tag ...). Что здесь "не так"? В многоточие вкладываются значения соответствующего типа. Это значит, что если тип none, то будет (tag) - это годится. Если целый, то (tag 999) - тоже годится. И с последовательностью также годится, там можно использовать синтаксис "[]". Хотя в Лиспе, в этом месте находится tail, т.е. можно сказать последовательность. А вот с записью как быть? Вариант "{}" несколько необычен. А если использовать прямое перечисление элементов до завершающей круглой скобки? Интересная идея. А если есть запись из записей или из объединений - тогда можно перейти на квадратные и фигурные скобки. В общем, правило здест такое: элементы последовательности перечисляются в квадратных скобках, элементы записи перечисляются в фигурных скобках. Но если "внешняя" конструкция является вариантом, то можно эти скобки опустить. !!?? Вроде получается. 

Еще один вопрос, который мешает, это множественность синтаксических вариантов, напр. допустим 
```
(func (param i32) (param f32) ...)
``` 
и допустим 
```
(func (param $p1 i32) (param $p2 f32) ...)
```
а также 
```
(func (export "numbers") (result i32 i32) ...)
```

Правда синтаксический "сахар" вроде убирается при трансляции-детрансляции. 

А еще проблема - отсуствующая модель памяти. Есть просто поле байтов и через смещение (offset) можно что-то читать и писать. Интересно, как должны быть встроены строки в программу. Обячно строки играют существенную роль...

Посмотрел в описания, работа со строками имеется, но непонятна. К тому же пока там ASCII, а не utf. 

### 20250907 10:32
А как можно реализовать мои идеи через WA? Наверное, надо формировать (дополнить) систему команд средствами работы со структурными значениями. Путь более или менее понятен: значнние или поле характеризуются type-value парой. Операции выполняются через интерпретацию этих пар. Возможно частичное исполнение, тогда может формироваться остаточная программа, которая будет довольно эффективной. 

Смущает в этом подходе "пара". Для WA это не естественно. Можно пару реализовывать двумя параметрами. И результат будет двумя указателями. Или одним указателем и одним значением. Возможно, мешает концепция одного стека. Было бы два стека... А если их специально организовать? Например в виде структуры данных. 

### 20250908 11:40
На предыдущем рассуждении я "застрял". Видимо потому что не смог понять способ реализации идей в инфраструктуре WASM. А если без инфраструктуры, а только с привлечением некоторых идей? Вроде система управляющих операторов довольно интересна, хотя так ли это важно...

Итак, предположим мы имеем поле типизованных значений. Типы - это такие же структуры, что и значения. Служебный тип TYP обозначает тип типа и это будет рассмотрено отдельно. Рассмотрим поле данных, доступных для обработки в конкретный момент. Это поле состоит из списков 

### 20250909 20:36
Контекст вычислений определяется несколько по-другому. 

### 20250911 10:15
Вот какая идея пришла в голову: я попробую сочинить функциональный язык программирования как набор функций обработки и управления. Потом хорошо бы реализовать этот язык и потом опробовать его на примерах или задачах.

ПредположимЮ у нас есть два вида значений: структура и поле. Структура всегда (?) является парой (значение-тип). Поле является ссылкой на значение, а тип - константа TIP (это тип типа). 

### 20250916 20:23
Несколько дней я занимался Rust'ом. Очень интересно, но сложно... Возможно, я вернусь к расту, но пока я устал. Хочется работать в контексте существенно более простых построений. Эти построения я уже наметил - это WASM, точнее WAT. А вот как их потом реализовать, это другой вопрос. Но сначала - построение. Имеется соблознительная идея: элемент объединения реализовывать через скобочную запись. Кажется, это ничему не противоречит, но следующее предложение - непрямую использовать S-выражение (tag tail) через то, что tail и есть значение подварианта. Но далее, надо ли использовать квадратные и фигурные скобки?       

### 20250917 05:39
Кажется, я чрезмерно увлекся Растом. Чрезмерно в том смысле, что прямая реализация типовых значений Поляра может представить проблему. Действительно, если нужно реализовать например последовательность, то где-то получается массив элементов с головами, размер которых определяется динамически. А Раст ящзык строгой типизации и насильственное приведение может оказаться затруднительным. Как в случае с C#. Похоже проще вернуться к реализации на WASM - там есть массив байтов и вычисляй себе что угодно... Пока заналя Растом, подзабыл WASM, придется вспоминать. Ухожу в проект WebassemblyMy.


Может мне попробовать сделать виртуальную машину на rust'е или на WASM'е? Возможно, система типов rust подходит для прямого описания поляровских типов. Возможно...   

Итак, что можно сделать с полем, что можно сделать со значением. Поле у нас будет типа F, значение - типа V. И поле и значение в интерфейсах представлены парой тип-значение этого типа: (F, F) или (F, V). Надо отрабатывать терминалогию. Тип языка реализации и поляровский тип - разные сущности. Как-то надо определять локальную запись. Потом через вариант поля типа loc^тип-записи определять локальные переменные. Потом через useloc^ делать первичное обращение к локалам. Потом издать функции получения полей, получения элементов и получения поля перечислимого типа.  
```
(loc 0) // поле, выделяющее нулевой элемент
(par 1) // поле, выделяющее первый параметр

```
