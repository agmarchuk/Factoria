# Размышления не тему использования структур Поляра для создания языка программировани или системы программирования

### 20250428 17:29 Мысли на тему
Со структуризаций Поляра почти все ясно. Не ясно: рекурсивные структуры типа TYPE и параметризация типовых построений. Пока это можно отложить. Далее, мы будем предполагать что есть аппарат лямбда-функций. Главное, что хотелось бы понять - это некоторый универсальный механизм работы с отображениями п-значений в ту или иную среду. Это может быть оперативная память, могут быть байтовые потоки и даже битовые потоки, это потоки интернета. Возможно также рассмотрения могут быть применимыми к хранилищам, в том числе, распределенным. 

Естественным образом напрашивается представление об источниках и стоках (sources, destinations). Берем источник (структурированных) данных, получаем из него структурное значение, напр. в виде потока объектов, преобразуем этот поток и заводим его в приемник. Либо поток используется по пути для чего-то полезного. Либо вместо источника создаем генератор и уже он порождает поток. Хорошо бы создать удобный формализм. 

Попробую get-set:
``` 
p-value = get(source);
set(p-value, destination);
```
В некоторых случаях источник может порождать под-источники. Например в случае регулярного размещения в ОЗУ структурного значения. Регурярное размещение подразумевает выполнение свойств: значение разбито на голову и хвост. Голова всегда фиксированного для данного типа размера. Поэтому можно данное этого типа "прикрепить" к приемнику данного типа. Для систем РВ (реального времени) перед прикреплением надо убрать хвост из поля и утилизировать ресурсы (памяти). Соответственно, должны существовать процедуры выделения полей. Напр.:   
```
source = field(source, [номер поля]) // для записей номер поля это константа
```
И получения атрибутов структур:
```
целое = count(source) // для последовательностей
целое = variant(source) // для объединений
```
Другим принципиальным вариантом исток/стока являются сериализации. Есть 2 варианта текстовой сериализации, байтовая сериализация (возможно в разных вариантах) и битовая сериализация (тоже в вариантах). Для сериализации важно иметь начало потока, пополнение потока, выявление текущего офсета, установка офсета, чтение элемента потока. Важно использование сериализаций в: базах данных, в коммуникациях, в командных интепретаторах (?). 

### 20250429 06:24
Пришла в голову мысль. Взять за основу подмножество C# и сочинить свой язык. Только применить другую систему структуризации. Поляровскую. Как это может выглядеть? Берем процедуры, в минимальном варианте классы и методы, берем произвольное число параметров (может быть...), берем yield return, берем основные управляющие конструкции. Берем поляровские структуры, берем потоковую обработку и отложенные вычисления. Все вышесказанное переводим в структурный вид, для него сочиняем несколько текстовых сериализаций и "протаскиваем" все это через механизмы обработки. 

Возможно важнейшей частью подхода может быть новая семантика приваивания. Суть не слишком сложная. Присваивание, это некоторые манипуляции между полем и (структурным) значением. А еще надо понять суть перечислителей. В C# они как-то не сильно концепуализированы. Может так и надо, может надо по-другому. Кроме присваивания может нужно именование. Хотя это вызывает вопросы. При именовании мы хотим сохранить структурное значение в уже вычисленном виде для того, чтобы его использовать в разных местах. Обычная схема сохранения - присваивание. Неудобство присваивания в том, что присвоенное значение можно менять, а мы может это не имели ввиду для повторного использования. А как можно сохранить значение без присваивания?

Теоретически, значение это набор объектов. Если его сохранять, то это будет то же сериализованное значение. То есть, некий вариант присваивания. Набор объектов интересен тем, что значения могут "крутится" в цикле обработки не захватывая память. Но так их не сохранить, нужно сериализовать.

Итак, есть основная конструкция - присваивание. Есть ее вариант, а может и основа - передача параметра. Передача параметра выглядит как "вложение" значения в поле, определяемое параметром. То есть, очень похоже на присваивание. Обработка присваивания происходит рекуррентно и "сверху вниз". То есть берется тип поля и берется "верх" значения и сопоставляются (matching?). Если тип простой (целый,... строка), то ожидается и значение соотвествующего типа. Если тип составной (запись, последовательность, объединение), то ожидается либо значение этого типа либо конструктор значения этого типа. В случае конструктора, сопоставление задает новые пары тип-значение. Процесс сопоставления, рекуррентно продолжается. Он останавливается на ситуации, когда тип значения совпадет с типом поля. 

Какие моменты можно выявить при сопоставлении? Для записи - ничего особенного. Правда в ряде языков matching используется для как-бы именования полей. Хорошо бы это использовать... Для последовательности можно было бы использовать и перечисление элементов и поток, который автоматически превращается в массив. Также не исключена конструкция "первый-остальные" либо "начальные-последний". В любом случае, пора подумать над переменными сопоствления. Кажется, пора выходить на логическое программирование. Я очень давно об этом мечтал. Может и предикатная форма будет уместна. 

Как бы аккуратно ввести переменные сопоставления, а потом их полезно использовать. Попробую стартовать от предикатной формы. Пусть есть предикат P(x, y). Это определяемый предикат, его определение (в Прологе) может быть каким-то типа:
```
P(A, B) :- Q(A, C), R(C, B).
```
Это означает, что предикаты определения могут иметь параметрами и константы и переменные. А переменные служат информационной "опорой" для вычисления чего-то другого. По старым своим прикидкам я выявил то, что образцы могут быть в заголовке определения, особенно если рассматриваются альтернативные типы. Это означает следующее: есть единая сигнатура функции, параметры в этой сигнатуре структурные. После этого, мы задаем заголовом функции с разными сопоставлениями и через них вычисляем конретный вариант тела определения. На этом пути есть трудности. Что если будут сопоставлены два и более варианта или ни одного?

Но с другой стороны, если иметь вариаты switch, можно каждую из алтернатив выстроить в систему обработки. И та же задача будет достаточно удобно решена. Кажется... Надо посмотреть как это делается в других языках, напр. Python.  

### 20250430 09:32
Из Питона также можно взять цикл по индексу, который там делается через итератор, что весьма логично.

Пройдусь по важным конструкциям, которые надо зафиксировать в языке. Определение метода, определение процедуры:
```
Definition =
    type^TYPE,
    meth^Type_result Type_object [formal_param]
    func^Type_result [formal_param]
```
Попробую начать с другой стороны. Со стороны исполнения. Пусть имеется определение функции. Функция не активируется пока не будет вызова. В вызывающем контексте есть стек данных и есть вызов функции. Оставим место для результата (пустое поле на стеке вызова), далее сформируем нужное количество пустых полей для параметров. Далее, вычислим выражения значений фактических параметров и вычислим значения полей. Последнее требует расшифровки. Значение поля это "указатель" на вычисленное поле переменной, которая не будет изменяться во время вычисления данной функции. Кстати, здесь намечается противоречие для процедур с yield return. Что такое "указатель"? Это некоторая координата по которой можно читать структурное значение и заменять его на другое. Таким образом, для параметров in выделяется место для реального значения, для параметров out и inout - место для координаты. Вычисление поля дает координату, вычисление выражения дает прикрепленное значение. 

После выделения места для параметров, в контексте вычисляются значения, помещаемые в фактические параметры. И запускается процедура. Процедура работает в контексте своих параметров. Что делать с доступностью и использованием переменных более "высшего" существования (глобальные и внешние локальные), я пока не знаю. В принципе, это непростая задача и решается она через стек вызова (кажется). 

Далее идут вычисления, определенные в теле функции. Это операторы присваивания. Соответственно, на каждую переменную (сразу) выделяется место и операторы присваивания строют на этом месте значения. Причем, оператор присваивания проверяет пустое ли поле и утилизирует (опустошает) поле перед занесением туда головы значения. Более общий случай оператора присваивания - это присваивание вычисленному полю. Это означает, что сначала идет вычисление значения поля в текущем контексте, т.е. координаты, а потом уже все остальное. Каждое присваивание "очищает" голову поля. Итак, у нас есть поля, переменные и указатели. Указатели - координаты головы значения. Указатели или координаты часто являются результатами промежуточных позиционных манипуляций и вычислений. Но есть и прямое запоминание - в фактических значениях параметров in/out. 

Продолжу анализировать процесс интерпретации кода функции. Есть оператор return. Он останавливает вычисления и возвращает управление вызвавшей процедуре. Для функций - он возвращает результат. Это означает, что в "ячейку" результата записывается голова вычисленного значения. И все локалы функции утилизируются. Вопрос: а может ли быть функция, которая вычисляет поле? Подозреваю, что не может, но я над этим еще не думал. Почему не может? Возможно потому, что надо сначала иметь поле внешнего объекта, а потом вычислять его подполе. Ссылки на внешние объекты мы получаем только через параметры in/out. Но по идее, они нужны или для взятия значений или присваивания значений. В любом случае, в теле функции вычисленное подполе мы сразу используем.   

Сейчас после обеда немного прогулялся и придумал вот что: написать модель, определяющую как устроена система обработки данных. Здесь не понадобятся конкретные операторы, управляющие операторы и т.д. Только значения, поля и указатели. А также - среда оперирования. 

### 20250501 14:26
Сегодня Первое мая! Даже не знаю как сейчас это праздник называется. Ну да бог с ним. Мысли "крутятся" вокруг заданной темы - модели работы с данными. 

Что входит в модель? 1) объекты достаточно произвольной природы; 2) типы данных; 3) представление о сериализации (или о проекции?); 4) координаты; 5) разные варианты свойств сериализации; 6) базовое отображение (проекция) на оперативную память; 7) работа с переменными; 8) сегмент (блок) обработки

Сейчас посидел на скамейке, подумал и... придумал(?). Придумал насчет параметризации типов. Сейчас в процедурном варианте я пишу, напр.:
```
var tp_seq = new Sequence(tp_el);
```  
А если допустить, что tp_el - это параметр, который при подстановке будет принимать разные значения? Интересно... Но наверное это исказит имеющуюся работу с типами. Может проэкспериментировать чтобы лучше понять?

Вот экспериментальный вариант программы:
```
using Polar.DB;
partial class Program
{
    public static void Main()
    {
        Console.WriteLine("Hello, World!");
        PType ty = new PType(PTypeEnumeration.integer);
        PType zap = new PTypeRecord(
            new NamedType("aaa", new PType(PTypeEnumeration.sstring)),
            new NamedType("bbb", new PType(PTypeEnumeration.real))
        );

        var v1 = new object[] {1, 2, 33};
        Second(ty, v1);
        var v2 = new object[] 
        {
            new object[] {"s1", 1.11},
            new object[] {"s2", 2.22},
            new object[] {"s33", 33.33}
        };
        Second(zap, v2);
    }
    private static void Second(PType seq_e, object sequence)
    {
        PType tseq = new PTypeSequence(seq_e);
        object el = ((object[])sequence)[1];
        Console.WriteLine(tseq.Interpret(sequence));
        Console.WriteLine(seq_e.Interpret(el));
    }
}
```
Она работает, а в процедуре Second задается тип-параметр seq_e и значение, адаптированное к этому типу. Это не слишком надежно (совсем ненадежно), но что делать? Может опять решать задачу "в лоб"?
Где здесь могут быть недиагностируемы ошибки? Очевидно, в конструировании объектов. У меня нет конструкторов объектов, но они могли бы быть. Вообще, о надежности программирования можно было бы озаботиться специально. 

Но это не все. Для корректности и удобства помнится в C# при указании суперкласса можно указать и некоторые его свойства. Но здесь (пока) не суперкласс. 

### 20250502 09:45
Подумал над параметризацией типов. Вроде даже с рынешней реализацией получается. Провел эксперимент, описанный вчера, сегодня его несколько модифицировал - получилось. Суть решения в том, чтобы типы также передавались как параметры и участвовали в процедурах наряду с константами. Единственное (надеюсь) слабое место - вычисление размера головы структурного значения. Для большинства типов (атомарных и конструируемых) значение головы фиксировано реализацией. Только для записи есть неопределенность в виде суммы длин составляющих подтипов. В Polar.DB я "химичил" тем, что для записей устанавливалась длина -1 и если при запросе определялось это значение, то длина вычслялась рекурсивным запросом. И записывалась в поле длины. Видимо придется это место изменить и размер головы всегда вычислять динамически и рекурсивно. 

Теперь надо вернуться к канонической форме процедуры. Допустим,  есть описание лямбда-функции:
```
lamda((t1, t2, ...), (x1, x2, ...) (операторы))
``` 
Фактически, есть набор типизированных параметров. Таким образом, есть поле значений которые можно использовать в выражениях с получением новых значений, результаты можно присваивать полям. Если не создавать побочные эффекты, присваивание может быть только для  промежуточных (?) переменных и результату.  

### 20250509 16:38
Мы вернулись с Семинского перевала и сейчас я обнаружил, что не зафиксировал важные, пришедшие в голову мысли. 

Главная новая мысль: рассматривать поляровские значения не как пары (указатель на значение, тип), а как тройку в которой добавляется "категория поля". Эта категория может быть довольно разной. Это поток байтов, это структурное значение, это поток битов, это разные модели TCP-взаимодействия. Кажется, вообще структурное значение приобретает другой смысл. Это координата в каком-то из подпространств.

### 20250510 06:41
Попробую продолжить рассуждения. Пусть есть источник или сток или переменная. Наверное, квалификацию менять нельзя. Также пусть есть определение вида потока: байтовая память, битовый поток, байтовый поток. Во всех случаях, есть координата поля. Какие манипуляции можно проделать с координатой? Кажется, что многое зависит от квалификации указателя. Если это сток, то put(value) изменит координату в указателе на размер величины или головы. get() даст двойной эффект: изменение координаты и получение значения. set(value) работает только для переменной и произведет очищение предыдущего значения и установку нового значения. 

Как-то мне не нравится наличие побочных эффектов, надо бы сделать изящнее. Начну с того, что есть три метода put, get, set. Или может только два: get(coor), set(coor, value). Это скалярные действия хотя и со структурными значениями. Надо ли вводить потоковые действия типа enumerable <- getflow(coor)? Неочевидно. Может лучше избавиться от абстрактного p-объекта и в операторах указывать и источник и приемник. Это как-то плохо выгдядит на фоне концепций функционального программирования.  

Попробую рассмотреть новые смутные идеи через "призму" потокового подхода и функционального программирования. Что такое поток с "физической" точки зрения? Рассмотрим фрагмент обработки:
```
foreach (var el in elflow)
{
    // Обработка el
}
```
Здесь важно то, что elflow - итератор. В Питоне (кажется) итератор вообще почти главная концепция. Что делает итератор? Он выдает очередной элемент и сдвигает "головку" чтения на следующий. Из-за побочного эффекта итератора могут возникнуть (и возникают!) ошибочные ситуации. Но пока это не важно. Важно то, что итератор последовательно показывает указатели на значения или сами значения. Проще считать, что указатели.  

### 20250626 11:08
Я серьезно задумался над потоками и итераторами и не смог увидеть простую подель за ними. Я попытался наметить обработку данных на стеке и опять же не додумал. Как все должно выглядеть? 

Мы запускаем прецедуру итератора, она перебирает элементы потока и подвергает их обработке. Подвергание обработке, это небольшое колчество базовых вариантов: генерация потока, поэлементное функциональное преобразование, фильтрация. Еще аггрегация и "размножение". Последнее - это когда результатом преобразования является поток элементов и эти потоки сливаются воедино через SelectMany. 

Ключивым для понимания обработки потоков является следующий фрагмент:
```
IEnumerator<int> enumerator = collection.GetEnumerator();
while (enumerator.MoveNext())
{
    var item = enumerator.Current;
    Console.WriteLine(item.ToString());
}
```
Создается объект "эньюмератор", потом организуется цикл с запросами к методам эньюмератора. Поток "съедается" внутри цикла. А если не съедается? Он может подвергнуться следующему этапу обработки, он может породить новый поток. Певое реализуется через вставление преобразования вместо выдачи. Второе реализуется через yield return. Кстати, а можно подобный yield return делать из блока или как-то так?

В вопросе реализации yield return существенным вопросом является то, куда девать наработанные значения потока. Может надо создать универсальный буфер? И переключаться с наработки значений потока к потреблению значений потока. 

Тогда что? Вернемся к
```
IEnumerator<int> enumerator = collection.GetEnumerator();
while (enumerator.MoveNext())
{
    var item = enumerator.Current;
    // Точка потока
}
```
В разделе "Something to do" можно 1) фильтровать, 2) преобразовывать, 3) редуцировать.
Далее, можно преобразовать item в поток (или последовательность) и устроить внутренний цикл и уже во внутреннем цикле будет точка потока.  
```
IEnumerator<int> enumerator = collection.GetEnumerator();
while (enumerator.MoveNext())
{
    var item = enumerator.Current;
    IEnumerator<T> enumerator2 = F(item).GetEnumerator();
    while (enumerator2.MoveNext())
    {
        var item2 = enumerator2.Current;
        // Точка потока
    }
}
```
Такая конструкция дает SelectMany().

А вот yield return видимо можно делать только с помощью буфера. 

### 20250629 08:52
Я все больше склоняюсь к мнению, что надо делать как в Rust: вызов параметра по значению, вызов по ссылке, вызов по изменяемой ссылке. Синтаксически это касается только спецификации параметров, а какой код должен быть опрелеяется в зависимости от квалификатора. 

Проводка ссылок внутрь процедуры не несет опасности пока мы через ссылку не меняем значение. В условиях "леса деревьев" изменение "ветки" несет ту опасность, что на этой ветке может быть другая ссылка, которая перестанет быть правильной. Как это может произойти? Посмотрим по индукции. Назовем ссылку независимой если ее значение не содержит других ссылок. Пусть, по индукции, все имеющиеся в контексте вычислений ссылки являются независимыми. Или свободными. Вычисления осуществляют следующее: выделяют поля, т.е. вычисляют динамические ссылки, вычисляют значения и присваивают поля значениям. Поскольку ссылки являются независимыми, динамические поля также явлются независимыми. И присваивание полю значения "закрывает" поле и соответствующую ссылку. А теперь рассмотрим вызов процедуры. Мы вовнутрь передаем значения и ссылки, обратно получаем значение, а может и поле. Последнее - под большим вопросом. Передача вовнутрь ссылок создает внутри нового контекста новые ссылки. Они могут быть зависимыми. Это когда передаются через разные переменные поля от одной ссылки (от одного поля). Кажется, это единственный вариант появления плохой зависимости. Достаточно запретить эту ситуацию и вроде все в порядке. Есть исключение: когда мы передаем новому контексту разные "по горизонтали" поля одной записи. Это может быть не только при процедурном вызове, но и при открытии нового блока. Например при сопоставлении с образцом. Что-нибудь вроде:
```
let a, b, c = record.a, record.b, record.c;
```
В общем, надо думать... Особенно про yield return.

### 20250706 16:12
Еще раз попробую сформулировать свои достижения. 

Определяем поляровскую типизацию. Причем тип может быть параметризован, это делается через сборку типа, в которой принимает участие параметр. Все типы неизменяемые. Видимо это же касается других статических объектов, напр. лямбда-функция. Но это не факт. Может надо ввести динамическую типизацию, это когда порождается объект на основе сконструированного типа. Может и не надо. Естественно определяются структурные значения (объекты?). Определяется сериализация и десериализация. 

Далее идет понятие контекста. Это есть множество доступных структурных объектов. Контекст формируется как иерархическая конструкция. Сначала попробуем без ссылок. Есть переменные, состоящие из головы и хвоста. Есть описатель контекста, который состоит из описания "результата" и описателя параметров. По спецификации на стеке выделяется память под голову результата. Далее, выполняется цикл, в котором для каждого параметра выделяется место под голову, выполняется выражение, формирующее фактический параметр. 

Попробуем логику начинать от вычисления значения выражения. Есть выражение (код), есть поле, т.е. способ вычисления указателя на переменную (на значение). Есть стек, в вершину которого помещается результат вычисления выражения. В промежуточных точках, стек используется для вычисления подзначений. По окончании вычисления кода, полученное значение расположено на вершине стека. Но может и не так. Может значение будет "развернуто" в каком-то месте, на которое указывает указатель. При этом мы исходим из того, что базовым оператором является оператор присваивания. На стеке лежит указатель места и именно это место используется в качестве переменной присваивания. Кажется, это очень важно. А как должно быть в динамике исполнения? Спецификация - вот решение. Допустим, есть переменная, новое значение которой вычисляется выражением. Переменная определена полем или ссылкой (что видимо одно и то же). Пусть поле находится на вершине стека.   
