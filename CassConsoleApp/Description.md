Надо сделать приложение, которое способно работать с fog-файлами. Некоторую основу я уже сделал. Берется fog-файл и 
переводится в корректную форму. Пока это касается только раскрытия iisstore, но можно (и нужно) расширить трансформации.
Итоговый XElement может сохраняться в виде файла. 

Для чего такие преобразования нужны? Во-первых, для более "аккуратного" представления fog-файлов, сказывающееся на 
скорости загрузки и использовании оперативной памяти. Во-вторых, для коррекции документов. Фактически, для перевычисления 
специальных (small, medium, normal) представлений мультимедиа.

Документы находятся через анализ fog-файлов. Вопрос в том, что запись документа может иметь uri вне данной кассеты. 
В принципе, можно работать с базой данных через API FactographData, но это будет уже другая история. 

### 20240510 10:12
Два или три дня я думал над выявленной ситуацией. Действительно, базироваться в переделках документа на первом описании,
опасно потому что потом это описание может перекочевать в другой fog-файл. В то же время, я не могу использовать всю базу
данных, по крайней мере, это затруднительно. Сейчас я склоняюсь к "ненадежному" решению, когда анализ и коррекция ведется 
первого описания документа. Дело в том, что атрибуты uri и docmetainfo не должны меняться со временем и при редактировании 
записи документа. В таком случае, старые значения этих атрибутов сохраняться в отредактированных копиях. Для uri - это 
очевидно, для docmetainfo - это не так, поскольку мы хотим менять метаинформационные поля, напр. ширину и высоту. Однако, 
я пока эти поля не использую, они нужны при создании превьюшек. Более того, от этих атрибутов и в последнем случае можно 
отказаться. Напр. уменьшая образ в 2 и в 4 раза. 

Попробую сделать как задумал. Для этого надо fog-документ перевести к каноническую форму. Если там выявляются ММ-документы,
то, в некоторых случаях, надо корректировать ширину и высоту, а если есть возможность - то и время съемки. При такой 
трансформации будет накапливаться командный файл для исполнения после фиксации нового варианта fog-документа. 

Действие 1. Создать кассету, с которой будут проводиться эксперименты. В кассете должны быть фотки, видео, аудио, PDF.

Сделал. Но далее был обед с Натальей Павловой, потом прогула по городку, теперь сел продолжить. Кассета t1 есть и содержит 
нужный контент. Теперь надо попробовать сделать программу нормализации фога. Работаю с метаинформацией.

### 20240511 07:41
Вчера сделал нужное преобразование для постого случая с получением канонической формы. Теперь надо бы добавить отметку 
времени, операторы уничтожения и подстановки. Это будет полный случай. Кстати, простой случай уже продемонстрировал 
работоспособность в использовании SypBlazor.

Есть еще одна недоделка в предыдущих разработках. Это формат вставления fog-документа. Там нет определения пустого 
пространства имен. Это легко исправить. Может быть, легко...

Оказалось, что не легко. Пришлось корректировать CManager, а он у меня очень старой версии. Тем не менее, домашний компьютер
сработал с этим кодом нормально. Осталось исправить загрузку аудио. 

Загрузку аудио исправить не удалось. Придется делать какое-то другое решение. Теперь я умею превращать метаинформацию в 
каноническую форму, при добавлении пользовательского RDF, файл, хоть и с пустым содержимым, сделан каноническим и если его 
изменения будут корректными, то все будет нормально. Теперь подхожу к коррекции метаинформации о документах. 
С метаинформацией по имиджам - считаю все нормально. Нужно взять метаинформацию по видео файлам и поместить в
docmetainfo.

Теперь "подкрадываюсь" к главному преобразованию. Идея заключается в том, чтобы обработать одну кассету. 
То есть, беру фог из метаинформации, преобразую его в каноническую форму, потом делаю подмену на 
вычисленное значение. При преобразовании, нахожу multimedia документы и пытаюсь что-то доделать. Для видео
с помощью MediaInfo определяю ширину и высоту кадра. Эти параметры вставляются в docmetainfo. Далее, 
обращаем внимание на дефолтные значения по преобразованиям. Сбрасываем преобразования в командный файл. 
Потом исполняем этот командный файл. Хорошо бы отслеживать  уже сделанные преобразования, но где это 
фиксировать, я не знаю. Поэтому буду формировать полный командный файл. 

### 202405 08:06
День Пионерской организации! Как давно это было...

Вчера нашел неточность в программе преобразования кассет, в части вычисления превьюшек. Это из-за MIME-тонкостей,
напр. расширения jpeg и jpg означают одно и то же, но надо это учесть. Пока оставлю эту тему, попробую доделать 
программу до работающего варианта. Для этого, как минимум, надо добавить определение метаинформации для видео и
перевычисление превьюшек. Попробую.

Делание превьюшек я "добил" (разве что аудио под вопросом), теперь надо для видео корректировать ширину и высоту кадра. 
Пока кадр получается со стандартными размерами, в итоге получается пустое место в кадре, особенно для вертикальных кадров. 

Пора заняться получением метаинформации через MediaInfo. 

### 20240520 09:45
Наконец, собранная конструкция заработала. Новая метаинформация не фиксируется в базе данных, но используется для вычисления
превьюшек. Надо маленько доделать и провести эксперимент напр. с семейным архивом. Доделать - это изменить место расположения
рабочих файлов и как-то организовать массовое перевычисление превьюшек. 

### 20240521 11:26
Я экспериментировал с Syp-массивом кассет. Выяснилось, что "главная" кассета SypCassete попрождает дефектные изображения
малениких фоток, пришлось разбираться. Разобрался, нашел подходящий старый вариант и потратил пару часов на то, чтобы маленькие 
оригиналы вручную заместить большими или средними. Справился, проверил. Теперь надо проверить работу конвертированных видео.

Проверил, работает. Улучшил визуализацию тем, что не фиксирую размер кадра, визуализируется в естественных размерах. 

Что теперь? Надо бы трансформировать кассеты семейного архива. 

### 20240522 12:12
При попытки поработать с семейным архивом, выяснилось, что некоторые кассеты не имеют наполнения раздела originals. А поэтому,
перевычислить превьюшки я не могу. Далее, я пошел по ложному пути и потратил некоторое время. Потом одумался и задумался о
том какие преобразования должны выполняться над кассетами. 

Пока видится два режима работы CassConsoleApp - вычисление превьюшек для конкретной кассеты или набора кассет и, второй 
замена оригиналов на более компактные, напр. tiff на jpeg. В дальнейшем, можно будет подумать о коррекции фог-документов. 
Итак, есть команда и есть путь к кассете или пути к кассетам. Последнее реализуется через использование файла с именем 
config.xml. Команда: preview | compress. Далее, вроде понятно. Попробую...

Перекомпоновал программу, оставил в "подвешенном" состоянии формирование канонического фога, испытал на вычислении превьюшек 
для некоторого теста. Теперь надо сделать режим compress. Вроде режим сделать довольно просто. Надо сканировать элементы,
выявлять фото-документы, находить их расположение, формировать источник и цель и делать преобразование.

### 20240523 05:03
Вчера вечером проводил большой (долговременный) эксперимент. Я преобразовывал некоторые кассеты в сжатую (compress) форму и
вычислял превьюшки. На этой второй операции - программа сбилась, выявила некорректное определение или использование 
xmlns. Действительно, в базе данных есть записи вида:
```
  <photo-doc rdf:about="Ma_0001_0223">
    <name>Ma 639_143</name>
    <comment>I:\Папка 639 Архив Г.И. Марчука (Документы и награды)\125 Список трудов\639_143.tif</comment>
    <iisstore uri="iiss://Ma@iis.nsk.su/0001/0001/0223" originalname="I:\Папка 639 Архив Г.И. Марчука (Документы и награды)\125 Список трудов\639_143.tif" size="11972832" documenttype="image/tiff" documentcreation="2022-02-17T05:46:41" documentfirstuploaded="2022-02-17T13:15:31" documentmodification="2021-06-08T06:54:37" checksum="qwerty" width="1701" height="2342" transform="" />
  </photo-doc>
```
А рядом записи вида:
```
  <document rdf:about="Ma_1005" mt="2022-02-17T13:15:46" xmlns="http://fogid.net/o/">
    <name>095 Записка об АН</name>
  </document>
```
Здесь есть две неточности: определение xmlns и использование mt вместо mT. Кажется, эти фрагменты порождены манипуляциями
по объединению в один документ частей (DocumentPart) документов. Странно также, что такие вставки произведены прямо в
current fog-файлы. Надо понять за что конкретно программа "цепляется". 

Возможно, я сделал стратегическую ошибку сопоставив пустое пространство имен с http://fogid.net/o/. Но что теперь делать? 
Исправлять все фоги? Не так уж их много накопилось. Но и не мало. Кажется, программу CassConsoleApp надо расширить командой
типа canon. И переводит кассеты и наборы кассет в каноническую форму. Есть нюанс: дополнитлеьные fog-файлы. Надо подумать
и, возможно, провести эксперимент. А много ли таких объявлений xmlns="..."? Посмотрел через far - многовато. Причем в 
разных вариантах: есть и с дефолтным определением, есть и посреди текста есть и в delete/substitute...

Что делать - до конца непонятно. Решил, что буду продолжать тестирование, а в сложных затыках вручную выпровлять текст 
фог-файлов. Начну с метаинформации к Ma.

С модернизацией (компрессия и перевьюшки) фамильного сайта я справился. Выглядит лучше. Теперь надо двигаться дальше. 
Я вспомнил, что вроде выявил ошибку в формировании древовидного построения и не смог придумать как ее устранить. И я 
эту ситуацию оставил в подвешенном состоянии. 

Надо попробовать выявить ошибку, если она есть. А потом искать способ устранения. Какие данные нужно ввести для того,
чтобы получаемый портрет был бы нетривиальный? Персона, имя, дата рождения, описание на разных языках, один родитель,
два-три ребенка, степени и награды. 

### 20240526 20:50
Разработка движется. После того, как я исчерпал идеи по поводу софта, который совершенствоал (MagBlazor,
CassConsoleApp), я решил заняться проектом минимального построения визуального образа фактографических 
сборок. Сегодня я занимался общим (художественным) дизайном, кое-чего добилася, можно продолжать. 

Требуется сделать определенные действия: 
1) Замаскировать служебные поля uri и docmetainfo.
2) Сделать вывод массивов документов в виде двумерной композиции (скорее всего, wrap).

Пока достаточно. Первый пункт я сделал, надеюсь там все корректно... Теперь задумаюсь о втором.
Можно пока "по-старому", сделать фотку или иконку. Наверное, это будет правильно. Только надо найти 
wrap-панель. 

### 20240528 15:22
Работа идет. То, что я запланировал, более или менее сделано. По мере испытаний и тестирования, выявилась "старая болячка",
которая уже проявляла себя: это какое-то наложение пустого пространства имен xmlns=... Я недоделал этот момент по причине
обязни менять базу данных. В принципе, приложение CassConsoleApp умеет вычислять новый fog-файл в канонической форме. 
Но подменять страшно... Хотя я придумал как это можно сделать без излишнего риска. Надо ввести в атрибуты fog-файла еще один
- версию. Тогда если при начале работы с файлом нет этого атрибута, значит это старый формат, если есть и нужная версия, 
то это оно... Такой способ позволит работать со всем массивом кассет и фог-документов и, при этом, постепенно переводить 
их в каноническую форму. Что дает каноническая форма? Надеюсь, что много. Во-первых, должны устраниться колизии по 
пространствам имен. Во-вторых, есть более экономная схема построения базы данных, а это важно. Уже сейчас, на некоторых 
больших данных, построение БД происходит за 1 минуту. Это долго... Я хочу расчитывать на объемы архивов в 100 раз 
превышающие нынешние. 100 минут еще не фатально, но уже напрягает. Еще больше напрягает объем захватываемой оперативной 
памяти. На упомянутых больших данных, это около 1 Гб. А это уже многовато. Сейчас я реализовал пару схем, которые 
захватывают раз в 10 меньше ОЗУ, над этим можно и нужно работать!

Попробую поработать с CassConsoleApp. Хорошо бы сначала четко зафискировать тестовые данные, дающие ощибку при обработке.

### 20240601 18:05
Вот и лето наступило... 

Я совершенствую Publicuem2, сейчас пора испытать на разных данных. 

### 20240602 12:33
Испытания привели к проблемным результатам. Более того, к нестабильным результатам. Для списков отражений,
некоторые отражения не воспроизводились. Попытка выявить причину как-то не удалась. Пока я не поменял
адаптер на rr, теперь вроде проблемы ушли. Хотя я не уверен. Не хочется расстоваться с адаптером upi,
но я не могу найти причину ошибки. Пока сосредоточусь на испытаниях решения Publicuem2 с адаптером 
rr. Попробую установить на своем рабочем компьютере. 

Вроде более или менее получается. Добавил документы, состоящие из частей. Пока нет сортировки частей. 

Сортировку сделал, но испытать негде - у меня документы, состоящие из многих частей, есть в открытом 
архиве. Хотя и в семейном также... 

### 20240610 20:26
Кажется, добился стабильности в работе SypBlazor и Publicuem2. Но надо двигаться вперед. Есть следующие
задумки: а) делать увеличение фотки от medium до normal (и обратно...); б) делать выдачу любого оригинала;
в) обеспечить маршрут - сложная фотка-оригинал-редактирование-сохранение фрагмента. 

### 20241228 12:12
Сейчас, перед Новым годом и каникулами, я хочу "разогнаться" в разработке фактографической системы. Я много забыл,
многое так и не доделал, но двигаться надо. Вспоминаю, соображаю, экспериментирую. Сейчас пытаюсь довести 
программу CassConsoleApp. Для этого надо ее сначала проанализировать. Попробую. 

Программа запускается из консоли и имеет параметры. Сначала идет команда preview|compress|collect, второй параметр 
- имя конфигурационного файла. Файл пока имеет стандартный вид config.xml. Есть вариант прямого задания (одной) 
кассеты, но пока я этот маршрут не опробовал, сейчас можно задать только одну. Отличается вариант тем, что концовка
второго параметра не config.xml. Для удобства пуска из студии и отладки, параметры можно задать в тексте 
программы как дефолтные. Также в тексте программы задается место для кода используемых приложений. Обычно это 
D:\Home\bin или C:\Home\bin. Список имен фог-файлов, предназначенных для данной обработки формируется в 
string[] cassnames. 

Следующий раздел называется "Развертка collect". Он запускается только если команда collect. 
Я уже не помню что это означает, придется поанализировать. В разделе из набора имен кассет формируется список
имен фог-файлов. В список помещается база данных из meta и все фоги, зарегистрированные в этой части базы данных.
Далее, в разделе делается цикл по таким фог-файлам. Фоги нормализуются, в частности, делается XML-документ 
с правильной конструкцией: с проставленными простраствами имен rdf и дефолтного. Еще находятся записи с элементами
iisstore, они преобразжуются в корректные конструкции. Сделал некоторую недоделку, испытал режим, вроде работает.
Команда collect больше ничего не делает, программа заканчивается. 

Следующий раздел выполняется без указания команды, т.е. для всех (остальных). Снова проводится цикл по кассетам. 
Здесь в программе задается значение структуры finfo, определяющей размеры превьюшек. 

Далее, идет раздел "compress" в котором данные tiff формата, преобразуются в jpeg. В базе данных это не фиксируется,
но это желательно учесть в выводе оригинала. 

Вроде все преобразования сработали. Правда заминка произошла на AVI-видео. Определитель типа файла дал
video/x-msvideo, а такого расширения у файла нет. Плохо только некоторая "безтолковость" корректора CassConsoleApp.
Что-то надо корректировать с одной командой, что-то с другой, что-то с третьей. Кроме того, довольно частое в 
практике действие по сжатию оригинала (часто оригинал сжимается во много раз). Надо бы сделать концептуально более 
простую схему. Там еще есть итоговая "канонизация", надо посмотреть что она делает. Похоже - ничего, надо убрать.
Еще одна проблема текущего решения: длительность обработки. На каждое действие запускается тот или иной процесс.
Но процесс может оказаться безуспешным. И к чему это приведет? Кроме того, на обработку тратятся ресурсы. Более 
экономным и надежным выглядит формирование командного файла и последующий пропуск его. В общем, похоже задача еще
не решена. Да, еще одна потенциальная проблема: формируются файлы на замену существующих. А как заменять? Можно 
новому файлу добавить к имени что-нибудь вроде ".xml". Это решение неудобно из-за того, что надо вручную искать эти 
расширенные имена, находить оригиналы файлов, оригиналы уничтожать, новые - переименовывать. Тут можно и ошибиться!
Другое решение - сразу делать такую замену. Здесь понятно мы будем хуже контролировать результат. В обеих случаях,
откат назад как-то не просматривается...

### 20250207 12:44
Я пытаюсь регуляризовать кассеты семейного архива. Это надо бы сделать с помощью средств данного проекта (CassConsoleApp).
Пока не могу даже начать. Это потому, что нет уверенности в надежности осуществляемых преобразований. Что делается и
что надо делать? 

Есть технические недоделки. В частности, директорию внешних программ, надо бы "таскать" с проектом. Также не достаточно
структурированы параметры, отстуствует "нормальный" способ включать и выключать этапы преобразований. Потом не совсем 
ясно как задавать параметры создания превьюшек. 

Начал "разгребать" указанные "завалы". Во-первых, нашел подходящий способ вычислять место запуска. Далее - три директории 
"вверх" и одну "вниз" на фиксированную директорию с кодами программ. Это разрешает вопрос с привязкой бинарников внешних
программ. Проверил работу кассете с фильмами. Все бы хорошо, но видео обрабатываются долго! Если это запускать каждый
раз, будет неоправданно затанута обработка. С превьюшками фильмов можно поступить довольно просто: если превьюшка уже
есть, то ее не вычислять, если нет - вычислять. Пока непонятно как вычислять сжатую копию оригинала, ну да ладно...

С превьюшками фоток можно поступить приблизительно также, но пока отложу этот вопрос. А с видео надо бы сделать.

### 20250209 06:48
Итак, кое-что я переделал в преобразователе кассет, теперь надо все доделать и испытать. Больно сильно сомнения
гложат. 

Значит, иду по следующему маршруту: а) обрабатываю заданные кассеты; б) в кассетах выделяю фог-документы; 
в) в фогах нахожу документы такие, как - фоги, - фото, - видео. Каждую из этих записей можно и нужно использовать
для каких-то коррекций. Фоги корректируются через изменение записи - вынесение iisstore. Записи <photo-doc> дают
возможность корректировать оригинал и, если надо - превьюшки. Записи <video-doc> используются для того, чтобы
вычислять/корректировать превьюшки. Теоретически, можно также корректировать оригиналы видео. 

Есть проблема или проблемка: записи могут дублироваться (с разными временными отметками), могут быть уничтожены. 
И, самой страшное, идентификаторы могут быть переименованы. По изменению фог-записей - можно изменять все дубли.
По фоткам - изменять tiff получится однократно если tiff уничтожать. Все то же самое, в случае видео. Таким образом,
самое надежное - просто уничтожать все, что может вызывать повторные преобразования. Откатов назад не получится, но
что поделать... Главное - проверять наличия файлов.

### 20250210 10:45
Медленно, очень медленно, но продвигаюсь в совершенствовании программы CassConsoleApp. Сейчас делаю замену tiff-ов
на jpeg-и. Сам файл я заменяю, теперь надо заменить метаинформацию о нем. Это раздел docmetainfo documenttype:image/tiff (image/tif)
который надо заменить на documenttype:image/jpeg. Пожалуй, сделаю. Также надо бы сделать параметр типа -tiff для включения опции 
преобразования тифов в жипеги. 

Смутила меня логика, которую надо выработать и воспроизвести. Проблема в том, что фог-документ иногда надо изменять. 
Такое "иногда" бывает когда а) формируется более поздняя версия документа на основе старого; б) производятся изменения в 
метаинформации документа или документов, напр. при замене tiff на jpeg. Случай a) - проще, надо всегда сохранять элементы в заготовке,
а потом записать сформированный документ по месту. Случай б) - несколько сложнее. Сложность возникает из-за того, что мы не знаем
появится ли изменяемый элемент или нет. Это значит, что заготовку надо формировать, а решение о ее сохранении принимать в конце 
формирования. Таким образом, в логике приложения должны присутствовать следующие переменные: 
- to_convert_tiff (-tiff) - внешнее указание, что надо конвертировать tiff в jpeg, когда есть возможность. 
- to_convert_video (-video) - внешнее указание, что надо конвертировать оригинал video в MP4, когда есть возможность. 

### 20250213 08:39
Что-то я застопорился. Причем на простом вопросе: как указывать оригинал, который надо компрессировать. Это надо, потому что
многие источники (фотки, телефоны) или авторы (корресподенты и др.) слишком "шикарно" пишут видео, напр. взятое у меня 
интервью тянет на 2.6 Гб в том же MP4, а нормально сжатое - 602 Мб, это даже без "игры" параметрами сжатия. Но в общую схему 
обработки CassConsoleApp не ложится. В отдельную программу выделять неудобно. В конце концов решил, что это будет специальная
опция в кассетном приложении, но пока не смог собраться для того, чтобы доделать его. У меня согодня в 10 семинар, а потом прийду
и начну работать.

Начал, но уже в 15:51... Тем не менее. 

### 20250215 12:49
В общем, с огромной потерей времени, я сделал начальный вариант программы CassConsoleApp. Проверил в разных режимах. Для запуска 
превьюшек, превьюшки не должны существовать или их (частично) надо уничтожить. Попробую выйти на комплексный тест. 

Попробую это сделать с какой-то копией кассет семейного архива. 

### 20250216 11:42
Какую-то подборку кассет архива я сделал. В основном, это те, которые использовались в текущей версии ИС Family. 
Теперь надо "оживить" подборку. Правильнее всего, начать "оживлять" приложением MagBLazor. Попробую. 

### 20250217 17:22
Подборку "оживил", потом попробовал переработать применив CassConsoleApp, вышел на ошибку, оказалась в данных, исправил, вышел
на вторую ошибку в данных. Исправил, преобразование завершилось, проверил работу средствами MagBlazor. Трудно сказать, но вроде 
работает. Теперь надо бы найти и исправить ошибку в редактировании по которой получалась ошибка в данных. 

Теперь можно сделать более регулярную систему работы с кассетами с нацеленностью на серверное решение. 

### 20250218 10:08
Провел эксперимент по редактированию данных. Как то все не так... Во-первых, пустая кассета, которую я специально сделал, 
не пожелала преобразовываться в формат fogid-2024. Во-вторых, при редактировании, получился авост. Возможно, это произошло из-за
(моей) путаницы при создании отношения члена коллекции. Но почему авост? Надо разбираться.

### 20250221 11:46
Я застрял на поиске ошибки при преобразовании данных средствами CassConsoleApp. В конце концов, разобрался. Дело в том, что (кроме
всего прочего) видимо magic.exe, которую я использую в качестве программы преобразования имиджей, иногда делает лишнее, напр. пишет
не один результирующий файл, а два, при этом, расширяя его имя. В принципе, это можно контролировать. Но я продумал и альтернативный
путь - использовать библиотечные решения по работе с имиджами, которые я использовал в CManager'е. Или другие аналогичные. Я посмотрел,
там истинно принципиального кода будет немного.  

### 20250228 10:37
Сегодня День рождения Пети. Как быстро летит время, ему уже 42...

Через неделю решил вернуться к разработке Фактографа. Тем более, получил звонок, что soran1957 не работает. Видимо машина остановлась.
А еще я приостановился из-за мыслей, что надо бы сменить схему обработки в CassConsoleApp. Дело в том, что разработанные средства 
можно использовать и для ввода данных Веб-приложением. Но надо получить откуда-то метаинформацию о документе. По видео я ее беру из 
запуска MediaInfo, а по фото из docmetainfo. Там она вычисляется при работе CManager'а. Надо от него избавиться, поэтому надо все-таки 
иметь возможность получения метаинформации не только из существующих данных. Метаниформацию можно получать через запуск MediaInfo или 
при прямой работе с имиджем. 

Итак, начну с библиотеки. Первое, что надо сделать, это получение метаинформации о документе. Сделаю процедуру.

### 20250303 12:00
В общем, я похоже разобрался в EXIF. По крайней мере, нашел код 36867 с помощью которого можно доступаться к времени съемки
```
var pr2 = im.GetPropertyItem(36867); // TagExifDTOrig
var t2 = Encoding.UTF8.GetString(pr2.Value);
```
По ходу, пришлось очень много искать некоторую ошибку, которая оказалась в том, что преобразование с помощью magic.exe
не формирует ряд тегов, в том числе и указанный, а это приводит к ошибке. Кажется так... Это уже вторая выявленная 
ошибка. Вывод заключается в том, что для имиджей надо отказаться от внешней программы Magic. Может я даже выиграю, надо
пробовать. 

Попробую набросать маршрут обработки. Что делать с новыми документами я пока не продумал. Пусть имеется набор кассет
как в предыдущем случае. Я сканирую фог-файлы, нахожу документы и, в зависимости от их типа, произвожу некоторые 
действия. Действия с фотками можно сгруппировать в единый пакет. Сначала я смотрю на имеющиеся метаданные по документу.
Если файл имеет расширение tif, то надо корректировать оригинал и корректировать docmetainfo. После этой корректировки
вычисляются превьюшки. Да и то, если а) было преобразование tiff -> jpeg; б) или превьюшки не обнаружено. 

Буду пробовать. Пожалуй, надо собрать новое приложение. Пусть это будет CassCorrect. 

### 20250312 10:52
Прошло 2 недели, я занимался перевозкой документов. Сейчас вроде уже назад акклиматизируюсь, могу продолжить. 

В принципе, новая схема обработки мне нравиться больше. По всем указанным в конфигураторе кассетам, собирается информация 
о fog-файлах. Потом фоги перебираются и каждый из них сканируется. При этом, строится новый вариант фога в виде XElement
объекта. Также, когда надо, помечается флаг tochange = true. Начальное состояние флага false если стоит нужная версия 
фога, иначе он сразу true. Также он может стать true если производится изменение какой-нибудь записи, напр. фотодокумент
изменяется с tiff на jpeg. Конкретно в данном случае, перевод tiff->jpeg будет осуществляться при наличии параметра -tiff.

Это все касалось изменений в fog-файлах. Далее, при анализе записей, выявляются записи определенного вида. Пока это
фотки и видео. По фоткам: если есть преобразование tiff'а и это есть tiff, то оригинал прочитывается в битмап. Далее,
проверяется надо ли делать превьюшки. Параметры превьюшек фиксируются в файле cassette.finfo, а необходимость вычисления -
в отсутствии файла превьюшки на месте. Если надо вычислять хотя бы одну превьюшку для этого документа, а битмап остутствует,
то битмап прочитывается. Потом вычисляются превьюшки и располагаются по местам. 

С видео, выполняется только создание превьюшек (пока я делаю только medium). Попробую продвинуться что ли...

### 20250314 16:26
Двигался, двигался и вдруг - застрял... А застрял я на осознании того, что часть архитектуры кассетной организации
НЕ ДОДУМАНО! Действительно, для документов, в том числе и ММ-документов, базисно верна схема распределения записей
и наличия множества одинаково идентифицированных записей с определением последней как оригинала. При коррекции, я не
строю базу данных и не определяю множеств одинаковых. Я просто последовательно беру запись и работаю с ее полями. 
В частности, с uri и docmetainfo. Как с этим быть? В принципе, если не меняются данные по uri и docmetainfo,
вроде все в порядке - оин копируются во все копии без изменений. uri не должен меняться по построению. docmetainfo
может меняться через изменение типа графики, ориентации, размеров, дат и др. 

В свое время я совершил ошибку тем, что отказался от разделения файл-документ с обратной ссылкой на документ. Если бы 
так, то документ можно было бы привязать к кассете (и даже к current-фог) и запретить изменять его средствами 
редактирования. Это было бы логично, также как логично не менять собственно документ. Процедура коррекции тогда была 
бы надежной. 

А что делать сейчас? Пока мета-поля находятся внутри документа, нужно сделать документы мало изменяемыми. Вообще-то
критичным в смысле возникших проблем является только uri. Как это использовать - непонятно. Можно, конечно, ничего не
делать...

### 20250315 10:01
Кажется, я прихожу к решению. Поля uri и docmetainfo я в документах пока оставляю, но верным считаю только uri, 
а для docmetainfo завожу 

```
  <Class rdf:about="http://fogid.net/o/FileStore">
    <label xml:lang="ru">Файл документа</label>
    <label xml:lang="en">File of document</label>
    <SubClassOf rdf:resource="http://fogid.net/o/sys-obj"/>
  </Class>
  <ObjectProperty rdf:about="http://fogid.net/o/forDocument" priority="a" essential="yes" weight="35">
    <label xml:lang="ru">для документа</label>
    <label xml:lang="en">for document</label>
    <inverse-label xml:lang="ru">контент</inverse-label>
    <inverse-label xml:lang="en">content</inverse-label>
    <domain rdf:resource="http://fogid.net/o/FileStore"/>
    <range rdf:resource="http://fogid.net/o/document"/>
  </ObjectProperty>
  <DatatypeProperty rdf:about="http://fogid.net/o/uri" priority="o">
    <label xml:lang="ru">uri код</label>
    <label xml:lang="en">uri code</label>
    <domain rdf:resource="http://fogid.net/o/FileStore"/>
    <range rdf:resource="http://fogid.net/o/string"/>
  </DatatypeProperty>
  <DatatypeProperty rdf:about="http://fogid.net/o/docmetainfo" priority="o">
    <label xml:lang="ru">docmetainfo</label>
    <label xml:lang="en">docmetainfo</label>
    <domain rdf:resource="http://fogid.net/o/FileStore"/>
    <range rdf:resource="http://fogid.net/o/string"/>
  </DatatypeProperty>
  <!--
  <DatatypeProperty rdf:about="http://fogid.net/o/contentType" priority="o">
    <label xml:lang="ru">content type</label>
    <label xml:lang="en">content type</label>
    <domain rdf:resource="http://fogid.net/o/FileStore"/>
    <range rdf:resource="http://fogid.net/o/string"/>
  </DatatypeProperty>
  <DatatypeProperty rdf:about="http://fogid.net/o/owner" priority="o">
    <label xml:lang="ru">owner</label>
    <label xml:lang="en">owner</label>
    <domain rdf:resource="http://fogid.net/o/FileStore"/>
    <range rdf:resource="http://fogid.net/o/string"/>
  </DatatypeProperty>
  -->
```
File фиксирует uri и другую метаинформацию и имеет ссылку на запись документа, напр. фото или видео.
Этот файл заводится в current-фоге кассеты, его не разрешается редактировать, поэтому он всегда там живет. Зато 
специальное и ручное редактирование не портит логику, поскольку он в одном экзампляре. 

А с текущими полями что делать? Давай так: оставляю docmetainfo для совместимости, но не сильно поддерживаю. 
Для отличия ситуации, добавляю в docmetainfo какой-нибудь код и формирую MultimediaFile со ссылкой на данный документ.
Таким образом, "старый" софт должен работать. А новый софт будет опираться на новое оформление мультимедиа. А корректоры
и транформаторы будут опираться на введенный признак. Вначале списка метаинформации помещаем version:old; Как-то так...

### 20250316 09:18
И каждый раз, когда надо писать код, я отступаю... В этот раз я задумался о внешних ссылках на документы. Допустим,
есть (облачное) хранилище фоток или видео или разных документных файлов. И пусть хранилище имеет простое API, тогда
вместо файла документа, вполнен уместна ссылка на этот контент. А как сделать ссылку? Проще всего, через вариант 
uri. Действительно, в позиции uri можно поместить гиперссылку. Если результат гиперссылки возврат самого документа,
то это действует как файл. За исключением типа документа, который неизвестно куда девать. За исключением атрибутов,
разных вариантов размера и т.д. Если есть возможность, то лучше брать из источника копию документа, оформить ее как 
надо, а где-нибудь указать источник. Пока я не буду заниматься этой проблемой. 

Вернусь к проекту. Продолжу программу с учетом того, что я придумал и продумал. Новое, что повлияет на общую организацию
обработки, это работа с "главным" фог-файлом в кассете вместо работы со всеми. С другой стороны, работа со всеми
может быть важной для других обработок или для проверок. Например, если важное описание каким-то образом появилось 
в дополнительном фог-документе, это надо бы знать... Но для начала, обработку можно упростить на один цикл. 

Заметил еще один нюанс: фоги не рекуррентны в том смысле, что current-документ может иметь документы типа 
application/fog, а внутренние - нет. Прямого запрета нет, но кассетный менеджер этого не допускает. 

А если введение файла отложить и сделать как раньше? Если преобразовывать главные фог-документы, а может и все,
дефект подхода провится только при явном использовании метаинформации. Часто можно обойтись без этого. В конце концов,
если очень надо будет, можно будет доделать преобразования. Так что, для того, чтобы минимизировать количество ошибок,
буду делать изменения в основных фог-файлах.

### 20250320 13:14
Время идет, программа очень медленно совершенствуется. Сейчас она может пропускать без обработки те части данных, которые
обрабатывать не требуется, может преобразовывать tiff в jpeg, может делать превьюшки. До видео я пока не добрался, 
остановился на том, что надо правильно поработать с управляющими параметрами. Добиться автоматичности в преобразованиях.

Неудобство разработки в том, что если заменять реальные данных, трудно следить за изменениями и восстанавливать исходный
вариант. Но попробую. Сделаю контрольное состояние тестовой кассеты и начну шаг за шагом отлаживаться. 

Сделал копию оригинала. Буду проверять работу имеющихся средств. Первое - очень важно. Это преобразование фогов, включая
вспомогатлеьные в версию прошлого года. Без перевычисления имиджей. 

### 20250321 05:30
Вчера доделал работу с имиджами. Вроде все режимы работают. Пока сегодня просыпался, захотелось сделать достаточно большой
эксперимент по нормализации/преобразованию. Видимо его надо проводить на рабочем компьютере, заодно и коммит на гитхаб
надо бы сделать. 

Коммит сделал, убедился, что на гитхаб могу посылать только с рабочего компьютера. Потом провел эксперимент с кассетой,
содиржащей около 30 Гб документов, в основном tiff. Все прилично работает, исправил одну маленькую ошибку, вернулся на 
домашний компьютер. Теперь надо сделать обработку видео. Предполагается, что видео документ уже помещен в кассету и
прописан в базе данных. Параметры видео кадра могут быть неправильными в docmetainfo. Главное, что надо сделать - сделать 
превью. Если превью существует, то эту запись пропускаем. Если не существует, то нужно а) получить метаинформацию через 
MediaInfo. Потом запустим ffmpeg с нужными параметрами. Коррекции docmetainfo делать не нужно. 

### 20250322 10:30
И я задумался... Задумался о том, как обрабатывать оригиналы внешними программами. Вроде все просто, обрабатываем, потом
вносим метаинформацию в БД, потом пересчитываем превьюшки.

И все же это потом. Сначала сделаю что задумал. 

Не сделал... Причина та же, что ранее упоминалась: хранить метаинформацию в документе неправильно. Это касается и видео.
Видео-документ, будучи отредактирован покидает свое current место и уследить за его последним экземпляром можно только
при помощи активированной базы данных. Короче, надо внедрять то решение, о котором я уже писал. Это будет еще одна особенность
версии фога fogid-2024. Формулирую явно:

В фогах более ранних версий, допустимо использование поля docmetainfo непосредственно в документе. В версии fogid-2024 и более
поздних, должны соблюдаться следующие правила:
1) использование docmetainfo в документе пока возможно, но не должно использоваться (новым) софтом;
2) в новых версиях, docmetainfo помещается в File, а он ссылается на документ, uri остается в документе.

Я пытался сделать другие имена для классов, ссылок и полей. Но сейчас склоняюсь к тому, что docmetainfo просто переносится в
File. Связующим звеном является ссылка forDocument. Минимум изменений. Сделаю эти именения для видео документа. 

### 20250324 12:19 
Кое-как преобразую программу преобразования. Пропустил на тесте, замечания:
- не преобразовался tiff, 
- обрабатывался вторичный фог
- в первичном фоге остались docmetainfo

### 20250328 10:50
Все-таки голова еще плохо соображает. Сделал программу, она не работает, но я не могу разобраться в логике построения
и исправить ошибку. Похоже, дело в неудачной структуризации программы. Попробую набросать структуризацию на словах.

Формирование параметров программы я пока оставлю, думаю проблема не в этом. Цель программы: модифицировать мм-документы.
Еще одна цель: перевести обрабатываемые данные в формат версии fogid-2024. Видимо из-за наличия двух разных целей,
мне не удалось сформировать прозрачную логику обработки. Вторая цель (задача) первичнее. То есть выполнять модификацию
мультимедиа на старом формате не получится. Значит, надо сделать форматирование, а когда оно будет работать нормально,
добавить и преобразование. Ура, воистину гениальная мысль:)

Итак, переформатирование. Здесь все должно быть просто. Берем любой фог-документ и начинаем "тупо" преобразовывать его
элементы. Мы должны разделить на 2 элемента любой документ, имеющий uri и docmetainfo. От элемента остается он же, но
без docmetainfo. В принципе, его можно оставить, но в дальнейшем не использовать потому что он может быть искаженным. 
Второй элемент, это элемент FileStore, ссылающийся на документ через ссылку forDocument. В этот элемент помещается 
тот же uri и изъятый docmetainfo. Как идентифицирован второй элемент - не существенно (на него ссылок не будет(?)),
я пока выбрал идентификатор документа с добавленным знаком "подчерк". Важно, чтобы FileStore образовался в единственном
экземпляре и в кассете, где хранится файл документа. Я выбираю более жесткий вариант: он помещается в основной (current)
фог кассеты. Чтобы были выполнены желаемые свойства, документ с uri и docmetainfo должен появиться в единственном экземпляре 
в любом (я выбираю основной) фоге кассеты. Но документ позволительно редактировать. И документ может переместиться и 
в другой фог и другую кассету. Я не допускаю редактирования указанных полей стандартными средствами, поэтому несколько 
экземпляров документа в основном фоге не должны мешать если будет создан лишь один (!) FileStore в этом фоге. Это
принципиально. Таким образом, если допускается несколько экземпляров документа в основном фоге, то надо следить за тем,
чтобы FileStore был единственным. Если один - то следить не надо, это свойство достигается автоматически. Но и следить
вроде не затратно: фог "под рукой", количество элементов в нем - максимум несколько тысяч. А можно создать простую 
хеш-таблицу или даже простое хеш-множество. Табличка наверное несколько надежнее, можно будет проверять совпадают ли
поля разных документов с единой идентификацией. 

Все вроде продумал, можно писать программу. Буду создавать новую из кусков старой. Сначала - "чистое" преобразование. 

### 20250329 10:51
Начальная основа новой программы работает. Документы старого формата преобразуются в новый. Теперь надо заняться
выделением элементов FileStore. 

Какая должна быть логика такой обработки? Сначала отбрасываем дополнительную обработку для фогов, которые не являются
основными. Далее, выявляем документ. Если версия старая, то (фото) документ должен (может) содержать и uri и docmetainfo.
Мы разделяем документ на два, дублируя только uri (и ссылку). Перед дублежом проверяем в хеш-таблице нет ли там 
такого-же. Если есть, но не такой, то сильно "ругаемся".

Вот я снова задумался. Я сделал то, что хотел, по крайней мере, первую часть своих желаний. Программа преобразует 
кассеты в нормализованную форму. А теперь надо бы это испытать, а как? Получается, что надо модифицировать визуальные
и редактирующие интерфейсы. Здесь недолго и запутаться. Есть, правда, промежуточный способ. Оставить (временно!) поле
docmetainfo. Вроде должно работать. А потом, сначала перевести на использование FileStore, а потом убрать лишнее. 

Какие-то большие масштабы... А память у меня стала небольшая, работоспособность - маленькая. Что делать? Не знаю...

### 20250330 06:52
Процесс идет, надеюсь, с ускорением... Я сформировал (восстановил) массив кассет Family, теперь попробую миграционные
преобразования. Сначала запущу MagBlazor на этом массиве.

Запустил, работает. Можно проверить и редактирование. ... Проверил, работает. Теперь проведу эксперимент по 
нормализации данных. Пока не буду отделять FileStore от документов, только нормализация. Посмотрю что получится.

Похоже, эксперимент прошел успешно. Хотя и не без проблем. Проблемы были в кассетах bogatykh и Marchuk_common, причем
в дополнительных fog-файлах. Ошибка была в переопределении пустого пространства имен xmlns=... которое переопределялось 
либо правильно, либо неправильно. Видимо неправильное переопределение вызывало системную ошибку в процедуре чтения файла.
Это когда "снаружи" xmlns="http://fogid.net/o/", а в некоторых элементах xmlns="". По крайней мере, переопределение
пространства имен rdf проблем не вызвало. Я исправлял неточность вручную. Сейчас исправлю и неточность с rdf. 

Теперь, на всякий случай, запомню новые варианты проблемных фогов и двинусь дальше. Запомнил. Вспомнил про еще
одну желательную оптимизацию: убрать лишние delete. Это можно делать когда в других кассетах нет переопределения.

Что следующее нужно проделать? Уже готово извлеение из мультимедиа документов FileStore. В принципе, я уже делал
и преобразование tiff'ов, изготовление превьюшек и другие действия. Да, вспомнил - надо проверить, что сборка будет
работать и теперь. Кстати, и режим редактирования надо проверить. Хотя бы на delete.

Напоролся на ошибку. Как всегда, разыменование нулла. Возникшая ситуация следующая: ссылка на объект есть, а
определения объекта в задействованных кассетах нет. Пока гулял, продумал как с этим быть. Решил, что надо 
генерировать ссылку с названием "нет в БД", а с гиперссылкой как будто нормально. Теоретически, можно заглянуть в
расширенную БД и найти определение. 

### 20250331 06:49
Все-таки нашел вчера ошибку и даже исправил. Суть исправления ошибки или неточности заключалась в том, чтобы
добавить альтернативный вариант в формирование прямой (Dir) дуги при построении записи Rec.

Я начну сегодняшние работы с испытания редактирующего слоя в MagBlazor. Ведь что-то создавало путаницу с
пространствами имен.

Провел эксперимент, проанализировал полученный фог. Вывод: действительно есть неточность - delete и видимо
substitute добавляются без пространства имен, поэтому в элементе появляются xmlns="". Посмотрю насколько это 
критично. Посмотрел, вроде локально это не критично, но надо устранить, чтобы в каноническом представлении этого
не было. 

Коррекций по элементам delete и substitute оказалось довольно много, особенно по delete. В ряде случаев, оставил
обработку и "пустого" delete и {http://fogid.net/o/}delete и также substitute, но в целом, считаю переход на 
каноническое представление свершившимся. Осталось добиться от этих элементов большей "каноничности", т.е. должно быть
что-то вроде:
```
<delete xmlns="http://fogid.net/o/" rdf:about="idofdeletedelement"/>
<substitute xmlns="http://fogid.net/o/" rdf:about="idofsubstitutedelement">
    <new-id rdf:resource="newid"/>
</substitute>
```
Второй элемент возможно правильнее заменить на SameAs. Я пока эти моменты не додумал.

Вернусь к разработке корректора кассет. Теперь попробую добавить преобразование тиффов. 

У меня возник вопрос: а можно ли обойтись без метаинформации docmetainfo? Что в метаинформации важно? Вид документа,
размер кадра, дата съемки. Наверное, это главное. В принципе, насколько это нужно? Вид документа можно вычислить по 
расширителю файла, размер не всегда нужен, дата съемки может быть записана в поля документа. Также метаинформация 
может быть вычислена по файлу оригинала. Что все это означает? Означает, что можно делать как я задумал ранее и
преодолевать возникающие затруднения. 

Итак, что надо добавить, чтобы преобразовать tiff-файлы? 

### 20250401 10:40
Опишу словами то, что хочется сделать как следующий этап. 

Теперь в корректор я буду добавлять работу с имиджами. Частный случай - tiff, который преобразуется в jpeg. Даже
опцию не буду задействовать, пусть он всегда преобразуется, когда есть возможность. 

Основной цикл по кассетам списка. В этом цикле прочитывается finfo-информация, готовится набор фогов данной кассеты,
организуется цикл по фогам. 

### 20250402 11:12
Вчера выполнил задание, проверил насколько быстро идет обработка. Достаточно быстро. Вся текущая подборка семейного архива
сканируется на предмет документов за 3 секунды. Правда дома у меня теперь довольно быстрая машина с быстрым SSD. После этого,
я задумался: а что я делаю? Я сканирую предоставленную базу данных, все чтол можно, перевожу в новый формат. Это делается
уже на первой фазе или итерации обработки. Потом, при сканировании, я более внимательно работаю с документами. Мультимедиа
документы меня интересуют только те, откуда извлекается полезная метаинформация. Сейчас я буду извлекать метаинформацию прямо из
файлов. Для этого, достаточно uri, что я сохраняю в документе. uri не меняется, а метаинформация может измениться. 
Последовательность работы по доступу к метаинфромации следующая: есть имя кассеты, по нему легко получается главный фог-документ,
в фог-документе могут быть несколько документов с одним uri. Внешнее требование к этим нескольким документам - все они должны 
быть одного вида (фото, видео, аудио или док) и иметь единый идентификатор. Возможно с точностью до переименования, но это как-то
сложно... 

Пока метаинформацию буду выявлять, вычислять и складировать, но не использовать. Только надо указать, что какие-то документы 
нуждаются в анализе. Такой анализ нужен, когда требуется перевычислить tiff и когда требуются превьюшки. А еще вычисления нужны,
когда фог - главный и когда фог не главный, но устаревший. 

### 20250405 11:15
Опять путаюсь с логикой обработки. Все же нет ясности в мозгах...

Во внешнем цикле я перебираю фоги. Фоги, которые новой версии и не главные (ismodern_fog_version && !iscurrent_fog), я отбрасываю.
То есть, в фогах новой версии, но не основных, нет того, что надо преобразовывать по формату файла, по файлу документа и по 
метаинформации документа. Остаются два варианта, правда они пересекаются, это - (1) старая версия фога, ее в любом случае
надо преобразовывать по формату и (2) фог главный, там не только преобразовывать формат, но и выявлять метаинформацию и делать
манипуляции с файлами. Таким образом, я объединяю эти два варианта именно по преобразованию формата. Сканирую фог, анализирую 
что за запись мне попалась. Выделяю очень простой вариант (а) - старая версия и фог не главный. Тогда элемент просто копируется в
выходной сбор. Всю эту веточку можно было бы выделить в отдельный цикл, но пока попробую так. Остается вариант "главный". Там есть
и старый формат и новый. В старом формате нужно правильно преобразовывать документ, убирая из документа метаинформацию и добавляя
элемент FileStore. В новом формате документ вообще нас не интересует, интересует только FileStore. При этом, у нас не будет прямой 
связи с видом документа, но косвенной будет достаточно. 

### 20250407 07:57
Что-то я уже не каждый день пишу в дневник. Но пока еще пытаюсь работать без перерыва в днях. Правда часто эта работа 
малоэффективна. Вчера серьезно уперся в проблему "переходного периода". То есть, как совместить процесс перехода на новый формат
с процессом модернизации работающего ПО. Я придумал следующее: в объектной модели, поле docmetainfo в записях заполняется не
только из прямого поля, но и, приоритетно, из поля обратной ссылки FileStore. Кажется для этого возможно использовать модель
r.Rec. 

Еще я продумывал альтернативную идею: уменьшить роль поля docmetainfo в досупе к данным. В принципе, вплоть до убирания хранения
этого поля. Действительно, для простого доступа к записям о документах, почти всегда эти значения не требуются. Это потому, что
все имиджи имеют формат jpeg, все видео - mp4. Проблема есть с документами. Есть документы формата .fog, есть .pdf, есть другие.
В крайнем случае, можно запросить файл и проанализировать его расширитель. Другой вариант (Эврика!) - изменить формат uri. Сейчас 
это просто имя файла без расширителя. Можно всегда или в конкретных случаях добавить расширитель как паллиатив. Паллиати́в 
(палиатив[1], пальятив[2], от фр. palliatif и лат. pallium «паллий, покрывало, греческий плащ, верхнее платье») 
— не исчерпывающее, временное решение, полумера, закрывающее, как «плащ», саму проблему.

Не знаю,.. уж очень это выглядит революционным. В принципе, введение специального расшиения может быть лишь опцией переходного 
периода, но это еще и оптимизирует доступ к документам. Оптимизирует тем, что для большинства случаев, доступ к расширенной записи 
не требует раскрытия обратной ссылки от FileStore. Хотя, скорее всего, это не существенно по сравнению с потерями на доступ к
файлу документа. 

Сделал тестовую задачу, буду шаг за шагом двигаться в сторону решения. Сначала надо вычислить метаинформацию. Я все откладывал это,
но уже надо просто по ситуации. Итак, сканирую если новый формат, то анализирую только элементы FileStore и вычисляю \
метаинформацию, которую помещаю в элемент соответствующим полем. 

Итак, что мы имеем? Делаю, как запланировал. Надо попробовать внести изменение в генератор r.Rec-записей, может поможет...

### 20250410 18:26
Все хожу "вокруг да около" какого-то решения поставленной задачи. Сегодня (на прогулке!) вроде придумал. Что же я
придумал? Я придумал - отказаться от docmetainfo и в прямом и в обратном вариантах. Допустим 
uri формируется, а никакого DMI не формируется. Где это может проявиться? Первое - в выдаче контента документа. Для 
превьюшек, всегда формат файла .jpg, для видио - (пока) .mp4, для аудио - .mp3. проблема может быть в других видах 
документов. Например, для .pdf. У нас эти документы не имеют превьюшек и выдаются целиком по HTTP-запросу и получая 
бинарный HTTP-ответ.  

### 20250411 10:10
Что-то я не так стал излагать идею. Начну снова. Итак, предположим, мы отказались от прямой или обратной фиксации 
метаниформации. Хотя обратная фиксация вроде не нарушает логики построений. Вопрос доступа к файлам мультимедиа документов 
решается следующим образом: мы можем добавить extention для uri. Там, где экстеншина нет, его можно получить дополнительным 
запросом к информационной базе. 

Что делать с другими мета-полями? Размер файла - это системное, можно вообще отказаться, поскольку файл есть. Дата фиксации
- напрямую трудно поместить в документ, пока это делается специальной процедурой формирования кассеты. Ширина и высота
при визуализации не используются. Так что единственное использование метаинформации - вид или mime документа. 


### 20250412 06:12
День космонавтики, ура! Вспомнилось, что Физтех он как-то был близок к этому. Правда больше к ракетным войскам.
8К63, 8К64 - загадочные индексы... 

Возвращаясь к выполняемому проекту, могу сказать, что в принципе, осталось не так много. Надо сделать так, чтобы
MIME вычислялась и по "старым" данным и по новым. По старым - через присутствующее в записи поле docmetainfo, по 
новым - через расширение uri. 

### 20250413 11:54
Не могу сообразить как сделать изменения экономно. Это означает, что...

### 20250414 10:28
Еще раз подумал над вычислением MIME, кажется разумным и универсальным решением будет комбинация двух: через расширение
uri и через "заглядывание" файловую систему. Причем можно начать с загляюывания и все должно работать, потом добавить 
расширение, потом отказаться от заглядывания. Еще раз буду пробовать. Как ни странно, наибольшей проблемой оказалось 
размещение процедуры нахождения extention'а. А какой у процедуры должен быть интерфейс? Что мне надо? Наверное, только 
extention, который дополняет uri. Попробую назвать функцию string GetExtention(string uri) и поместить ее в FDataService.

### 20250422 11:50
Вроде уже сделал нужные изменения. Только превьюшки не вычисляю, но где-то код у меня уже был... Надо испыать. Это сложно, 
поскольку есть множество программ с частично пересекающимся кодом, поскольку есть множество приложений, множество фрагментов
данных. Но что-то уже должно работать. Попробую цикл (неполного) преобразования кассет, визуализации и редактирования с
помощью MagBlazor.

Что-то снова доделал. Вспомнил как перезагружать MagBlazor - правильно, надо набрать /room216/. Работает. Попробую 
более массовое преобразование форматов. 

### 20250424 09:12
Уже совсем скоро поедем на Семинский! Надо готовиться и по работе. Что я там буду делать кроме гуляния и питания?
Есть варианты: работать над программами, работать над данными напр. семейного архива, работать над статьями и
докладами. Уже надо готовиться к семинару...

Наткнулся на еще одну существенную тонкость. Дело в том, что я позволил в CManager'е вращать имидж. Алексей 
Фурсенко этим активно пользовался. При вращении оригинал не вращается, в iisstore проставляется атрибут 
transform="r" (90 град. по часовой стрелке), либо rr rrr. А перевычисляются превьюшки. Поскольку этими механизмами
Алексей активно пользовался, нельзя совсем игнорировать iisstore или docmetainfo. 

Идея заключается в том, чтобы при трансформации кассеты средствами CassCorrect, учесть информацию из iisstore
или docmetainfo и выполнить повороты над оригиналом, потом уже сделать превьюшки. Что-то подозрительное здесь
есть. Получается, что файлы можно поворачивать или менеджером или системными средствами. Это понятно. Но как
пользоваться системными средствами когда мы не знаем в каком формате fog-документы? 

Еще один нюанс: метаинформация, встроенная в фотку. Сейчас я проверил - если поворачивать, то дата съемки по
EXIF не меняется, меняется время доступа (последнего изменения) к файлу. Так что, использование системных средств
не сильно влияет на современные снимки. К тому же, дата съемки фиксируется как можно раньше, в принципе, еще до
поворотов. По крайней мере, делается попытка делать именно так. 

Итак, попробую подвести итог. Кассеты, сделанные менеджером и отредактированные (по поворотам) менеджером, в 
какой-то момент (и пораньше!) должны быть переведены в каноническую форму. При таком переводе, надо учитывать 
имеющиеся iisstore или (?) docmetainfo поля transform. docmetainfo я почти везде "вытравил" их решений группы 
Factoria. 

### 20250425 08:17
Нужен план работ, которые надо выполнить до отъезда.

1. Доделать изменения в решении Fatoria. Сохранить изменения в гитхабе. 
2. Провести комплекные эксперименты по демонстрации работоспособности.

### 20250426 06:30
Опять лечение зубов помешало поработать...

Пока просыпался, появилась (забрезжила?) идея. Речь идет о моем новом замысле сочинить подход, основанный на
структурированных данных. Поляр-структурированных. Идея брезжит о том, чтобы сделать единое 64-разрядное пространство
(псевдо) адресов. Часть этого пространства отображается на байты оЗУ, часть - на байты файлов, часть на интернет-потоки.
Более того, есть еще битовые потоки, есть еще тексты командной строки, возможно есть еще что-то. Так вот, источником 
или приемником данных может быть вход этого пространства. В выражении это просто идентификатор или адрес, но при
интерпретации будет задействована та или иная схема доступа. Причем "точки" годятся и для чтения и для записи. И то
и другое "в кавычках". В общем, есть о чем подумать... А еще идея - почему бы с данным не связать три (!) указателя:
указатель на значение, указатель на тип, указатель на хранение. Как-то так...

Вернусь к разработке. Надо доделать схему с iisstore.

### 20250509 16:20
С днем Победы! Вчера мы вернулись с Семинского перевала, а сегодня я уже пытаюсь собрать мысли для новых действий. 
Для начала, я скопировал два архива в которых есть измененные за поездку и добавленные файлы. Посмотрел что изменилось. 
В репозитории Factoria почти ничего. Только начальные мысли по инициируемому проекту "Новая модель поляровских данных". 
Пока не придумал названия. Пока файл novoprog.md находится в директории docs, надо будет подискать более подходящее 
место. И вообще, с md-файлами удобнее работать в VisualStudio Code. Пожалуй поработаю с этим файлом и зафиксирую то
важное, что пришло в голову на Семинском. 

Записал. Хотя мыслей оказалось маловато. Теперь займусь следующим проектом. Это вот этот. Конкретнее - Cass_Correct. 
Попробую вспомнить в каком состоянии я остановился.

### 20250511 15:12
Что-то я все путаюсь в логике обработки кассет. Надеюсь, когда-нибудь закончу. Исправил очередные ошибки, теперь вроде 
уже почти работает коррекция фото-документов. Но наверное, не в полном объеме и вообще, надо проверить. 

Проверяю. Сначала сформирую кассету, чтобы были и повороты и разные tiff/gif/...

### 20250522 09:33
Время идет, караван движется... Медленно. Я, в основном, закончил коррекцию кассет. 

Что программа делает?
- Преобразует fog-файлы из старого формата в новый, записывает новый фог если изменился контролируемых фогом оригинал;
- Преобразует оригиналы tiff в jpeg;
- Вычисляет превьюшки имиджей;
- Преобразует видео в mp4 (даже если это mp4) если бит-рейт больше 4,5 млн. бит/сек;
- Вычисляет превьюшки видео.

Изменение фогов сопровождается сохранением старого (предпоследнего) значения в имя_фога.fog.old
Вычисления превьюшек производится если превьюшки нет (уничтожен или переименован файл). Изменение оригинала видео, 
попрождает новый оригинал под именем NNNN.neworiginal.mp4. При этом предполагается, что видео может быть просмотрено 
и вручную переименовано в NNNN.mp4.

### 20250525 12:07
Я застрял на каких-то ошибках в коррекциях файлов. По памяти, это не срабатывание поворота картинки системными 
средствами и второе, не вычисление фотопревьюшек. Первое уже "прилетало" и тогда я решил, что это ошибка (фича!) 
операционной системы, когда фотография вроде и поворачивается, но не поворачивается. Я решил, что просто надо найти 
программу, которая поворачивает правильно. Но не нашел... И вот она снова!

### 20250526 09:20

### 20250528 11:20
Разрываюсь между несколькими проектами. Самые "горяие" - это коррекция кассет (вроде закончил), "мой язык" - это изобретаю новый язык программирования, основанный на структурном подходе, новый сайт ШЮП. 

Вчера, на защите диссертации, начал соображать по языку, рисовать какие-то картинки. Что-то 
стало получаться, хочу попробовать записать. Буду исходить из парадигмы калькулятора. То есть, 
в консоли вводится какая-то формула, она исполняется, результат появляется на той же консоли. 

У меня все значения типизированы. Без типа не обойтись, но для определения типа достаточно одного: TIP.
уже можно вводить значения, напр.:
```
Construct(TIP, integer^) или (Construct TIP integer^)
```
Некоторая проблема в том, что создавать дерево, по данной теории, можно только в контексте, в 
котором задан тип этого дерева. Но поле можно вычислять и без внешнего типа. Соответственно, 
конструкция
```
Формула-вычисления-поля
```
Вполне укладывается в концепцию, также как и 
```
Ass(Формула-вычисления-поля, формула-вычисления-выражения) // оператор присваивания
```
Для чего нужна изолированное вычисление поля непонятно, а оператор присваивания - понятен. 
Оттолкнемся от присваивания. Что это за поле вычисляется? Какие есть варианты? Это параметр из контекста 
параметров (из записи параметров), это локал из записи локалов, это какой-то источник или какое-то 
хранилище. Как изображать параметр или локал? А что должно получиться в итоге? Что-нибудь вроде
par^номер или loc^номер. Можно spar^идент или sloc^идент. Тогда номера легко определяются в контексте
определения функции (даже ее сигнатуры). Видимо важно и то, что легко выполняется и обратное 
преобразование - из номеров в идентификаторы. Да и размечать идентификаторы не нужно - их не много и
на стадии трансляции и идентификатор легко сопоставляется с элементом одного из списков. 
Но как я предположил, возможна передача поля через параметры.

Я уже продумывал эту ситуацию. Передача ссылки выглядит нормально если присваивания делаются корректно. 
Тем не менее, есть статические объекты, напр. типы, которые запрещено полностью или частично изменять.
Эти объекты живут до момента, когда попродивший их контекст не стирается. Типовые объекты используются
для порождения новых типов, напр. параметризованных типов. Также они используются для создания
структурных значений. Также типы используются для статического и динамического контроля.

В контекст обработки также может включаться еще и объект, методом которого эта фукнция является. 
Хотя если позволять ссылки, то технически, это уже не важно. Для какой-нибудь чистоты, можно было 
бы запретить ссылки или изменения по ссылкам для всех параметров, кроме собственно объекта. 

Минимизируя вариации, модель может содержать передачу не только значений, но и ссылок. Есть
серьезная проблема в передаче ссылок. Если по ссылке можно делать изменения, то можно предположить 
возможность передачи в один обрабатывающий контекст ссылок, относящихся к одному дереву, но на 
разных его уровнях. Замена поддерева на более корневой части, может вторую ссылку превратить в 
ведущую в "никуда". 

### 20250529 09:52
Уткнувшись в проблемы с моделью памяти, я вспомнил, что какие-то любопытные решения сделаны в 
языке Rust. Теперь создал рабочую обстановку, изучаю документацию и провожу эксперименты. 

Один вывод уже пожалуй я могу сделать. Техника "перемещания" очень похода на то, что я называл 
"открепление". Действительно, перемещаемая переменная отдает свое значение другой, а сама 
определяется недействующей уже на стадии компиляции. Мое решение полностью динамичное: хвост от 
поля открепляется и прикрепляется другой голове. При этом, предыдущее поле по-прежнему 
функционально, но "обнулено". Нужна ли статика в этом процессе, не знаю. Но аналогия просматривается. 
Есть разница в дефолтных решениях. В Rust a = b означает передачу (перемещение) значения, а 
корректное (полное) присваивание делается через a = b.clone(). Еще одна разница в том, что в Rust 
есть типы, реализующие Copy, в Поляре это атомарные типы плюс записи, рекуррентно состоящие из 
атомарных типов. Еще, может быть, часть объединений - перечисления. 

Кроме присваивания, перемещение осществляется при использовании переменной в виде параметра вызова
функции. Непроизвольно возникает вопрос: а зачем? При присваивании вроде мы могли бы пользоваться 
старой переменной. Но вот для функций - другое дело. Надо это обдумать. 

Познакомился с концепцией ссылок. Вроде это то, что у меня может быть как "поле". Идея защиты памяти 
заключается в том, что вне функции структурное значение не меняется, поэтому ссылка на его часть или 
на все значение, вполне оправдана. Если позволить делать изменения по передаваемым ссылкам, то 
мозжет возникнуть упомянутая ранее коллизия. Это все хорошо для неизменяемых ссылок. А что для
изменяемых? И вот оно решение этой задачи в Расте: на одну переменную может быть сделано не более
одной ссылки!

Почитал дальше. Ссылок может быть несколько. Но не более одной изменяемой. Как-то так... Далее
были рассуждения по поводу срезов строк - я мало что понял. Возможно, это корректный подход к
классическому для C подходу к указателю на элемент массива. Главное, что со второй попытки я уже 
понял хоть что-то!

Подведу промежуточные результаты. С откреплением - надо вспомнить и продолжить. Со ссылками - нужны
ограничения. 

Немножко продолжил читать описание языка. Снова обратил внимание на наличие концепции перечисления,
которая очень близка полровским объединениям. 

Теперь попробую просуммировать то, что пришло в голову по поводу нового языка. Сначала - общая 
концепция структур данных, типы и значения, выражения и поля. Потом переходим к "калькуляторному"
подходу. Набираем (в консоли) некоторую формулу - что-то происходит. Результат выдается на консоль. 
Формула набирается в каком-то сериализационном синтаксе. Проработана основная возможность - базовый
синтаксис Поляр-значений. Но похоже, более интересным вариантом является скобочный синтаксис. Это 
тестовая сериализация, но со скобками. Возможно, с сокращением. То есть, объединение будет выглядеть \
как 
```
(tag) или (tag, value) // объединение
{v1, v2, ...} или {k1:v1, k2:v2, ...} // запись
[] или [v1, v2, ...] // последовательность
```
Может фигурные скобки надо заменить на круглые. Может надо вернуться к записи tag^value. 

Но это только значения. А нас интересует программный код. Это формулы что-то определющие или
что-то вычисляющие. Код определяется следующими типами:
```
Code = 
    val^ (Type, Value), // Value - интерпретируется в контексте Type
    let^ (Field, Value), // Field вырабатывает тип, который становится контекстом для Value
    tp^ (Name, Value), // имя типа и значение типа TIP
```
Тип может быть определен статически либо динамически. Статика хороша для компиляции, динамика
хороша для параметризации. Если динамика будет мало стоить, то может надо двигаться в эту сторону.

### 20250530 07:25
Еще важная вещь - присваивание и именование. Именование позволяет зафиксировать контекст, есть 
область видимости, в общем - как в Rust. А ежели работать в иерархии контекстов? Есть какой-то
внешний. Это типы, переменные источники, стоки... В нем (через стек) появляется следующий уровень.
Это могут быть определения и могут быть вычисления. Определения можно свести к вычислениям через 
ламбда-функции или просто через функции. Но тогда не появятся ли смешанные вычисления? Может это 
и хорошо, может и не очень... Возможно это и есть функциональное программирование. 

Итак, попробую изложить мысли в виде функционального подхода. Главная операция - присваивание. Или
именование? Есть исходный контекст в виде множества (именованных) объектов. Состояние этого 
конгломерата измегняется через выполнение определенных действий. Главное действие - исполнение 
функций. Запускается run, формируются фактические значения параметров, исполняется тело функции.
Если не смотреть на побочные эффекты, то в результате работы функции переменные или поля изменяют 
свои значения. Со структурными значениями все понятно. А как понимать изменение типов и функций?

Типы изменяться не должны! Они - объекты единственного присваивания. В этом случае, вроде бы не 
требуется явно вычислять типы, а надо лишь указать их имена и структуру. Допустим, мы имеем класс
со структурой и методами. Можно было бы определить такой класс как struct AAA { переменные }. А 
внутри определить типы, включая параметризованные. Как обычно задаются типовые параметры? Напр.:
```
Dictionary<string, XElement> dic = new();

```
Как интерпретировать этот оператор? Берем объект (класс) Dictionary, проставляем в виде фактических
параметров указанные типы, и что? Мы, в итоге, должны получить (указатель на) тип и использовать его
в операторе присваивания. Как выглядит этот тип? Рассмотрим более простую спецификацию:
```
(string, XElement)[] dic = new (string, XElement)[0]
T = [string, XElement]; 
```

### 20250531 05:58
Важная особенность Rust это конструкция match, которая следит за указанием всех вариантов перечисления, а
в моем случае, объединения. Но я плохо спал не из-за этого. Я все думал о конструкции let поле = выражение.
Думал в контексте "гонок" и запретов Rust на записывающие ссылки. А у меня на этой конструкции
построена целая концепция... Надо изучить опыт Rust'а.

Касательно присваивания полю выражения: если есть два поля одного и того же дерева, то изменение 
одного значения может уничтожить поддерево, на которое ссылается другое. Действительно, проблема 
имеется. 

Пока досыпал, вроде сообразил, что все у меня не так плохо! Дело в том, что при присваивании полю
выражения, поле порождается и тут же используется. Это как в примере:
```
fn main() {
    let mut s = String::from("hello");

    {
        let r1 = &mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &mut s;
}
```
Во внутренних фигурных скобках ссылка порождается, используется и исчезает. Возможность создавать
переменные в которые помещаются значения полей - пока рассматривать не буду. Но дело в том,
что ссылка может передаваться в функцию. А у меня вроде было намеренье фактическими параметрами 
иметь только структурные значения. Если позворять передавать поля в функцию, то это, по крайней
мере, логично по части параметрических типов. По части других видов значений это может быть оптимизированное 
значение если параметр in, поле для присваивания, если параметр out, и переменная, если параметр 
inout. 

### 20250601 09:10
Вот и лето началось! Надо ускоряться с моими активностями, четче планировать. А я отвлекся на
концептуальную проработку... Займусь-ка я делами.

Что мне надо?
- готовить мастерскую
- создавать сайт ШЮП
- готовить доклад на Марчуковские чтения

Пожалуй, это главное. Начну со второго. Попробую сделать макет сайта в минимальном стилевом 
оформлении. Причем, нашего "парадного" сайта.

### 20250603 13:32
Что-то получилось, но сомнения замучили... Вернулся мысленно к языковому проекту. 

Я заблудился между значениями, полями и ссылками. Начнем с некоторой модели. Модель назовем "контекст".
Это множество "точек", через которые можно влиять на данные. У каждой точки есть тип и есть квалификация,
т.е. это точка есть источник, сток или переменная. Может у точки есть набор методов и можно их "дергать".
То есть, точка может быть инстансом класса. Эти точки - дело будущего модели, принцип наверное тот же.
Итак, основа модели - переменные. Переменные характеризуются местом размещения, ссылкой (координатой),
типом. Тип задаетсяя ссылкой на типовый объект. Типовые объекты изменению не подвергаются. Другие
объекты имеют период "жизни" после которого, они (автоматически) уничтожаются. Ссылка может указывать 
на промежуточные уровень какого-то объекта. Изменение значение по ссылке означает открепление и 
утилизацию "хвоста" и создание нового "хвоста". Это есть полное присваивание. 

Итак, типы совсм не меняются, появляются и утилизируются согласно времени жизни. А живут они относительно
долго. Обычно типы формируются при загрузке программы. Некоторые - при сборе параметрического типа. 

Поскольку ссылка может вести не в корень дерева, нужно предусмотреть защиту от зависших ссылок. Когда 
появляется ситуация зависшей ссылки. Это когда в одном контексте имеются ссылки на сопряженные части
дерева. Вообще, откуда берутся ссылки и где они обитают? Если ссылка появляется в результате исполнения
цепочки выделения полей, то как она фиксируется. Каноническое присваивание поле = выражение не фиксирует, не запоминает
поле. Единственно, когда поле фиксируется, это при формировании процедурного вызова. Тогда внутри
процедуры, хотя бы в теории, есть зафиксированное поле. 

### 20250607 17:28
Я почти написал HTML для нового сайта ЛШЮП. В принципе, это оказалось не слишком сложно. Для 
большинства случаев достаточно оказалось базовых средств HTML и CSS дополненных flexbox'ом. В
двух случаях, для декоративного оформления, пришлось поискать решения в Интернете, с чем я успешно 
справился. Это временная ось (timeline) в виде вертикальной линии с кружочками. И второе - скрытое
содержимое. Не искал еще одно оформительское решение - фотографии в кружочках. Сейчас посмотрю,
может все не сложно. 

Посмотрел, действительно, запрос "html css фотографии в кружочках" вывел на пару решений. Для
квадратных фоток:
```
<img class="circular--square" src="woman.png" />

CSS
.circular--square { border-radius: 50%; }
```
Для прямоугольных:
```
HTML
<div class="circular--portrait">
<img src="images/woman-portrait.png" />
</div>

CSS
.circular--portrait { position: relative; width: 200px; height: 200px; overflow: hidden; border-radius: 50%; }
.circular--portrait img { width: 100%; height: auto; }
```
Вроде еще есть решение для помещения в кружочек background фотографии. Все, закончил. Надо подумать
над языковой моделью.

Итак, все было бы идеально, если бы не было присваивания по полю, пришедшему через параметр. Ну а
если допустить? Например, пусть есть общая запись, поступающая на вход. Можно эту запись разделить на
поля через механизм сопоставления. При этом, не возникнет ситуации "доминирования" какой-то ссылки.
По любой из ссылом можно производить и чтение и запись. Если внутрь контекста "проникнет" две или 
более "конкурирующие" ссылки, то мы внутри уже эту ситуацию разобрать не сможем. 

Главная ситуация, которую надо попробовать контролировать (синтаксически?), это отстутствие 
конкурирующих ссылок. Допустим, в каком-то контексте имеется ситуация "отсутствия". Сможем ли
мы сохранить это свойство для внутренних вызовов? Что мы имеем? Множество переменных и множество
ссылок. И эти множества обладают указанным свойством. Это значит, что ни какие поля указанных 
объектов не находятся в конкурентных отношениях если эти поля начинаются от разных переменных. 

Таким образом, мы можем проверить выполнение указанного свойства для каждого вызова процедуры. 
Кажется, что нельзя возвращать ссылку. 

### 20250608 12:43
Сегодня - день рождения папы, ему исполняется 100 лет! Я - в Москве. Завтра-послезавтра будут московские юбилейные мероприятия, собственно за этим я и приехал сюда. 

Пока лежал, подумал об астракции. Пусть есть структуризация типа поляровской. Пусть она реализована каким-то образом. Главное, чтобы была голова и хвост. И желательно, чтобы голова была фиксированного (для типа) размера. Хорошо бы, чтобы теория подходила не только под Поляр,
но и под (модернизированный) С. Пусть есть значения и есть ссылки. И значения и ссылки типизированы. Правда система типов может быть не Си-шная. Рассмотрим локальный контекст. В него
входят переменные и параметры. Мы будем предполагать, что при входе в локальную область переменные инициализируются. И вообще, любой объект и любая ссылка являются корректными структурными значениями. Сразу предполагаем, что значения являются иерархическими. То есть значение состоит из подзначений, которые, в свою очередь, являются такими же иерархическими значениями. 

Что это дает? Можно говорить о поле и о его выделении. Из значения выделяется одно или несколько полей. Или значение атомарное. Выделенное значение можно "прочитать", т.е. перевести в формат системы программирования. Иногда поле используется для присваивания. Иногда, потому что должно выполняться свойство возврата или утилизации хвоста. Скажем при линейной развертке, это свойство не выполняется. 

### 20250609 09:06
Итак, есть контекст в виде множества типизированных точек. Типизированной точкой будет пара - 
указатель на объект и указатель на тип. То, что тип является таким же типизированным объектом,
это пока не существенно. Каждая точка дает возможность выполнять два действия: выделение поля с получением типизированной точки и, второе, чтение или запись объекта. Запись объекта на место выделенного поля выполняется в два этапа: открепление хвоста и его утилизация, перепись головы нового объекта на "освободившееся" место. 

Этот уровень контекста предполагает его "жизнь" в виде выделения полей, считывания информации из этих полей и изменение значений полей. Точнее, логическая последовательность такая: изменение объектов полей меняет состояние контекста. Единичное изменение заключается в вычислении поля, вычислении объекта и присваивания полю этого значения. Каждое такое изменение является корректным и сохраняет корректность всего контекста. Как это доказать? Надо определить корректность (согласованность, или как-то еще), определить действия и доказывать то, что действия не измненяют корректность. Далее, мы вводим создание локального контекста. Это как бы фигурные блочные скобки с параметрами. 

Локальный контекст создается из контекста через передачу "внутрь" рабочей области части точек контекста. Кроме того, добавляются локальные переменные. Эти переменные инициируются при создании локального контекста и уничтожаются при выходе из него. Также, в локальный контекст передаются значения и ссылки из контекста. Все должно быть типизировано. Рассмотрим динамику создания, функционирования и завершения локального контекста. Это удобнее делать на стеке вычислений. Сначала попробуем разобраться что является результатом выплнения локального контекста. Поскольку внутрь мы передаем в том числе ссылки, результатом могут быть изменения по ссылкам. Но все же, давайте запланируем основной результат. Это значение, лежащее на верхушке стека. То есть после выполнения действий в локальном контексте, останется или должно остаться. одно значение заданого спецификацией типа. Если оно не используется, то должно утилизироваться по общии правилам. То есть, хвост значения возвращается планировщику памяти, указатель на голову, просто сдвигается.   

### 20250610 07:02
Попробую задать семантику через интерпретатор. Пусть есть стековая машина. На врешину стека
можно положить либо структурное значение, т.е. пару: значение-тип (ссылка на тип этого значения), либо типизированную ссылку, т.е. пару ссылок: на поле и на тип этого поля. Сответственно, пусть есть поле структурных значений. Каждое структурное значение определяется 
координатой, это дает ссылку, головой - некоторым набором позиций устройства значения и хвостом, т.е. теми построениями, которые прикреплены к позициям головы. Дерево структурного построения однозначно интерпретируется и разбирается при утилиации. Структурное значение может быть инициировано. Инициирование производится через "расчистку" места для значение. При этом, такая "расчистка" или обнуление, формируют осмысленное структурное значение.       
Также сруктурное значение может быть "обнулено", что фактически означает приведение головы значения в исходное состояние и утилизация хвоста.  

Немного отвлекся и поразмышлял насчет реализации конвейера потоковой обработки. Понял, что это не тривиально, что надо будет еще серьезно об этом подумать...

Размышления на тему надо ли передавать параметры по значению как-то не получаются. То кажется, что надо, то нет... Возможно дело в том, что находить i-ый параметр легче. Хотя это зависит от конструкции стека. Если в стеке иметь параллельную часть - адрес предыдущего или следующего значения, будет полегче. Но еще легче будет если использовать запись как перечисление использованных переменных или параметров. Возможно, нужно несколько обобщить запись добавив туда типизированные и квалифицированные ссылки. Квалифицированные, это когда указывается параметр in, out, inout. А может в модели, параметр должен быть всегда inout. Но очень важно, чтобы тип не мог бы быть изменен внутри контекста. Мы можем создать новый тип и передать его во внутренний локальный контекст, но не можем изменить имеющиеся типы. Это понятно - значения, порожденные в данном контексте и переданные "снаружи" опираются на конкретные типы. Если тип изменить, то наступает катастрофа. 

Предположим запись расширяется на ссылки inout, но если тип ссылки будет TIP, то эта ссылка не может использоваться для изменения значения. Теперь как организовать контекст? Допустим, одна запись определяет набор параметров. Другая запись - набор локалов. Еще нужен набор статических объектов (типы, процедуры, возможно классы). А еще нужен контекст системы программирования (надо бы найти более удачное название). Суть этого контекста: иметь входы/выходы в программу (файлы, потоки и др.). Кстати, .я уже думал над трансляцией. Например, идет идентификатор переменной. На каком-то уровне обработки, мы просматриваем записи разных контекстных спецификаций и заменяем идентификатор на указание точки и номер элемента записи. Интересно, насколько большими будут накладные расходы на интерпретацию?

Попробую зайти с другой стороны, от компиляции и запуска на исполнение. Пусть есть базовая система структуризации. Параметризацию пока учитывать не будем. Есть представление о типе, представление о значении и о сериализациях. Берем исходный код, в котором описываются статические объекты программы: типы, константы, процедуры или функции. Процедуры компилируются во что-то, возможно, в псевдокод. Потом производится загрузка. Если не используются внешние описания/объекты,  то просто загружаются процедура Main() 

### 20250621 18:30
Я много чего сделал, но не писал в дневнике. Главное, удалось "справиться" с Windows-2012 сервером и установкой 
IIS на нем. В итоге, я поставил множество кассет syp_cassettes и запустил SypBlazor. Правда сервер пока не имеет 
доменного имени, но есть IP адрес: 84.237.72.94. Набираю в браузере http://84.237.72.94/SypBlazor и выхожу на 
собранную базу данных и документов с интерфейсом SypBlazor. Пока не проверял редактирование, надо будет проверить. 

Потом я увлекся написанием учебного пособия для своей мастерской. Но теперь задумался о сервисе к этой базе. 
Потребость существует, ее надо быстрее осуществлять. Как это должно выглядеть? Думаю, что документы выдаются по uri
как обычно. Айтемы должны выдаваться в каком-то объектном виде. 

Сейчас посмотрел. Похоже, наиболее надежным является использование интерфейса IFDataService:
```
        IEnumerable<XElement> SearchByName(string searchstring);
        IEnumerable<XElement> SearchByWords(string searchwords);
        XElement GetItemByIdBasic(string id, bool addinverse);
        XElement GetItemById(string id, XElement format);
```
Более того, только первых трех методов. Надо пробовать. Куда бы это поместить? Кажется, к минимальному API надо
приделать:
```
app.MapGet("/", Soran1957.SborSoran1957.CreateHtml);
app.MapGet("/docs", Soran1957.ShowDocs.CreateMime);
```
Только не CreateHtml, а CreateXml.

Это понятно, но в какой проект это надо внедрить. Наверное в новый проект минимального API FactographWebApi.

### 20250622 09:30
Подставлять функциональный параметр, в данном случае, не очень наглядно. Нагляднее будет подставить лямбда-функцию. 

Попробую что-то вроде:
```
app.MapGet("/photo", (HttpRequest request) =>
{
    string fn = "wwwroot/img/virus.jpeg";
    string ct = "image/jpeg";
    return new MimeResult(fn, ct);
});
```
Это работает, теперь надо сделать и другие MIME-типы, хотя бы видео. 

Сделал видео. Пора переходить к xml-результатам запросов. Сначала делаю подключение к фактографическим данным, потом
делаю поиск и потом выборку записи. 

### 20250623 02:08
Кое-что сделал, сервис данных начал "дышать". Теперь перешел на рабочий компьютер в частности для того, чтобы
сенхронизоваться с репозиторием. 

Пора задуматься над тем что я делаю. А делаю я универсальный интерфейс к фактографическим данным. Во-первых,
это источник данных. Для этого есть входы через XML и через MIME. Через XML

### 20250727 19:32
Прошла Летняя школа, надо дооформить списки, фотографии, видео. Поробую сделать это самым простым
образом. Начинаю "классическим" простейшиим API. 

Сгенерировал web, подсоединил к решению Factoria - работает. Теперь подсоединю адаптер данных.
Попробую это сделать не через "снглтона", а созданием объекта. 

### 20250804 11:25
За прошедшее время я написал новый проект визуализаци фактографических данных, назвал его Uno. Видимо что-то еще не доделал, но хочу испытать его на сервере. По ходу переноса проекта на сервер снова "набрел" на плохую русскую кодировку в коде, порожденном в VS. Я взял текст программы Program.cs в обычный  Notepad, выяснил, что он кодирован как ANSCI и записал его обратно в кодировке UTF-8. Надеюсь, поможет. Теперь попробую провести эксперимент с собранными данными ЛШЮП. 

### 20250808 17:17
Я капитально застрял на визуализации мультимедиа. Дело в том, что есть разница в формировании физических URL 
длЯ варианта отладочного и варианта опубликованного. Я уже позабыл как это преодолевается, пришлось читать 
кучу документации и проводить массу экспериментов. В конце концов, случайно, набрел на статью в которой давалась 
рекомендация использовать (псевдо)функцию URL.Content(строка_URL). Попробовал применить в последнем проекте Tres это
решение - получилось. Обрадовался! Даже решил, что все в порядке и можно вернуться к проекту Uno, который мне нравился
поскольку он целиком сделан на Minimal API. Не тут-то было!.. Оказалось, что Url и его методы как-то хитро запрятаны
в дотнете. Поразбирался, ничего особенно не поняв, я решил вернуться к Tres. Жалко потерянную неделю...

Сейчас попробую довести Tres до работающего состояния. выявляю вопросы - пишу, решаю - пишу. 
1*. Мелкая неприятность: отладочный заголовок в самом начале.
2*. Источники перевести на строку тип, ид, ...
3*. Ссылка в документе на отражениие (персоной) является некорректной. 

Попробую исправить и проверить на сервере.
4*. Работа с полями поисковой формы 
5*. Проблема с раскрытием элемента коллекции

Вспомнил и заметил 4 и 5. Вроде все исправил и в автономе проверил. Сейчас опубликую и посмотрю как получится. 

Кажется, получилось. Теперь перенесу систему на "настоящий" сервер. Только надо сообразить что делать с экспериментами. Duo я уже 
убрал, остались Uno и Tres. Пока оставлю оба.

### 20250809 10:00
Начал изучать информационный контент сайта syp.iis.nsk.su/SypDb. не все работает и не очень понятна система. Из конкретных 
проблем выявляются следующие:
(1) Есть старые матералы ЛШЮП в моих архивных папках. Не ясно что использовано, что нет.
(2) Видео из кассеты Syp2011video не желает воспроизводиться. 

Попробую разобраться в (2). 

и опять замечания:
6. Исправить (первую) ссылку на логотипе
    
после проверки нового решения по контролллеру видео - все вроде в порядке. Проверка перезагрузки по room216 - перезагрузка 
осуществляется, но возврат идет не туда. 

### 20250810 13:40
Возврат починил. Теперь думаю об оформлении. Похоже, для более качественного оформления придется делать правки не только 
в данных, но и в коде. Поэтому попробую синхронизировать данные на сервере и на рабочем компьютере. Кстати, надо разобраться в том
какие данные SypCassete используются. Итак, перекидываю наработанные данные на рабочий компьютер.

### 20250811 09:20
Перекинул, подработал, сформировал параметры загрузки, испытал. Что дальше? Собирался оформить начальную страницу. 

Для начала, надо сформулировать что я хочу, чтобы было на начальной странице. 
1. Информация о текущей подборке. 
2. Информация о данной базе данных и документах.
3. Коллекции документов (тематические)
4. Ссылки на другие источники информации по данной тематические
5. (может 0) Цель проекта, использованная технология

Есть вопросы, которые непонятно как делать. 
- Где располагать информацию текстового или гипертекстового характера?
- Как обеспечить правильный порядок элементов коллекции ?

Сначала посмотрю в онтологию на коллекцию. Нет ли там поля типа номера страницы? ... Посмотрел. Есть коллекции, коллекции любых
системных объектов, но номеров страниц там нет. Есть документы, есть части документов, у частей есть номера. Возникает нежелательная двойственность: можно сборку сделать через документ с частями, можно как коллекцию. uri есть у системного объекта, так что титульный имидж или лого можно сделать в любом случае. 

Кстати, пока не появились ошибки, хорошо бы дать очередное имя онтологии, точнее - очередной номер, напр. Ontology_iis-v14.   

Попробую оформить страницу входа как документ с разделами. Редактирование буду проводить в MagBlazor.  

### 20250812 08:31
До оформления я вчера не добрался. Сначала "наткнулся" на то, что преобразованный видео-файл формата .mts "потерял" звук, потом стал искать причину. Но поиски прервались прогулкой с женой. А после погулки и ужина, встречались с сыном в кафе "Кельн". В общем, вернулся к поиску сегодня с утра. Эффект я нашел, причина - видимо чья-то ошибка, а что делать подсказал "Искусственный интеллект". Подсказка была в серии дополнительных проверок и манипуляций. В частности, была рекомендация поменяь аудио кодек. Так что для .mts файлов я поставлю "заплату" в ffmpeg-преобразователе:
```
ffmpeg -i 0003.mts -c:v libx264 -c:a libmp3lame output.mp4
```
libmp3lame и есть другой рекомендованный аудио кодек. Оказалось, что .mts файлов в базе документов не так уж и мало, и все они имеют указанную проблему. Точнее, преобразованные из них в .mp4 файлы "не звучат". Есть повод для массовых преобразований. 

Пока испавлял, нашел еще одну существенную неточность, исправил, уменьшил порог для сжатия оригинала в 2500. Теперь перевычисляю видео и их превьюшки.

### 20250813 22:12
Порог сжатия пришлось увеличить до 4000. Иначе программа пытается сжать уже сжатый оригинал. 

